{"mappings":"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","sources":["<anon>","dist/index.js","src/index.ts","dist/utils/common.js","src/utils/common.ts","dist/utils/overloads.js","src/utils/overloads.ts"],"sourcesContent":["//Removes nullish values from provided object\nconst $cca413c873b82bf5$export$e3c872aa2ab87149 = (obj)=>{\n    return Object.fromEntries(Object.entries(obj).filter(([, v])=>typeof v !== \"undefined\" && v !== null));\n};\nconst $cca413c873b82bf5$export$6aa9081c568366ea = (element, prop)=>{\n    Object.keys(prop).map((key)=>{\n        if (element.type === key) {\n            const index = key;\n            if (!element.className && !element.id) throw new Error(`Please provide a class or id for element: ${element.type}`);\n            if (element.className) {\n                const el = document.querySelector(\".\" + element.className);\n                if (el) prop[index] = el;\n                else throw new Error(`Could not find element with className: ${element.className}`);\n            }\n            if (element.id) {\n                const el = document.getElementById(element.id);\n                if (el) prop[index] = el;\n                else throw new Error(`Could not find element with id: ${element.id}`);\n            }\n        }\n    });\n};\nfunction $cca413c873b82bf5$export$9b7692f0c207a7cd(value) {\n    if (value == null) throw new Error(`Error: value ${value} cannot be null/undefined`);\n}\nfunction $cca413c873b82bf5$export$953570f03e48e201(coords) {\n    //IF there is no props in the provided object\n    if (Object.keys(coords).length <= 0) throw new Error(`Error: no coords exist on this object`);\n    //IF the provided value of said object is not type of a number\n    Object.entries(coords).forEach(([k, v])=>{\n        if (typeof v !== \"number\") throw new Error(`Error type ${k}:${v} must be of type number`);\n    });\n}\nfunction $cca413c873b82bf5$export$c60994988c361040(index, action, steps) {\n    if (action === \"increment\") return index += steps;\n    else return index -= steps;\n}\nconst $cca413c873b82bf5$export$6d5a273f7a8fcfca = (type, parent, styles)=>{\n    const element = document.createElement(type);\n    if (styles) Object.keys(styles).forEach((k)=>{\n        Reflect.set(element.style, k, styles[k]);\n    });\n    parent.appendChild(element);\n    return element;\n};\n\n\n\nfunction $9403128a2a74c1da$export$bf395ed26c12da18(drawing, resizing) {\n    let coords;\n    //Make sure that coords are not undefined\n    resizing ? (0, $cca413c873b82bf5$export$953570f03e48e201)(drawing.resizedCoords) : (0, $cca413c873b82bf5$export$953570f03e48e201)(drawing.coords);\n    if (drawing.type === \"line\") coords = {\n        startX: resizing ? drawing.resizedCoords.resizedStartX : drawing.coords.startX,\n        startY: resizing ? drawing.resizedCoords.resizedStartY : drawing.coords.startY,\n        endX: resizing ? drawing.resizedCoords.resizedEndX : drawing.coords.endX,\n        endY: resizing ? drawing.resizedCoords.resizedEndY : drawing.coords.endY\n    };\n    else coords = {\n        x1: resizing ? drawing.resizedCoords.resizedX1 : drawing.coords.x1,\n        y1: resizing ? drawing.resizedCoords.resizedY1 : drawing.coords.y1,\n        x2: resizing ? drawing.resizedCoords.resizedX2 : drawing.coords.x2,\n        y2: resizing ? drawing.resizedCoords.resizedY2 : drawing.coords.y2\n    };\n    return coords;\n}\n\n\nclass $44f51f21f2de7984$var$DrawingCanvas {\n    canvas;\n    context;\n    controller = document.getElementById(\"toolbar\");\n    //Base tools\n    tools = {\n        pencil: document.getElementById(\"pencil\"),\n        eraser: document.getElementById(\"eraser\"),\n        moveAndResize: document.getElementById(\"mv-rz\"),\n        text: document.getElementById(\"text\"),\n        line: document.getElementById(\"line\")\n    };\n    //Tools for changing state of tools\n    toolModifiers = {\n        color: document.getElementById(\"color\"),\n        width: document.getElementById(\"lineWidth\")\n    };\n    //Tools for changing state of Canvas\n    canvasModifiers = {\n        clear: document.getElementById(\"clear\"),\n        undo: document.getElementById(\"undo\")\n    };\n    //For state tracking\n    actions = {\n        drawing: false,\n        erasing: false,\n        moving: false,\n        resizing: false,\n        writing: false,\n        lining: false\n    };\n    shouldDraw = false;\n    shouldErase = false;\n    shouldMove = false;\n    shouldResize = {\n        toggled: false,\n        from: \"\"\n    };\n    shouldLine = false;\n    activeTools = {\n        pencil: false,\n        eraser: false,\n        moveAndResize: false,\n        text: false,\n        line: false\n    };\n    mouseIsDown = false;\n    isDragging = false;\n    index = -1;\n    selectedDrawingIndex = null;\n    //Create default path object\n    pathObject = {\n        type: \"stroke\",\n        path: new Path2D(),\n        resizedPath: null,\n        lineWidth: 5,\n        strokeStyle: \"black\",\n        operation: \"source-over\",\n        coords: {},\n        resizedCoords: {},\n        xCords: [],\n        yCords: [],\n        resizedXCords: [],\n        resizedYCords: []\n    };\n    //Create default text object\n    textObject = {\n        type: \"text\",\n        text: \"\",\n        font: \"30pt sans-serif\",\n        resizedFont: \"\",\n        baseline: \"top\",\n        operation: \"source-over\",\n        coords: {},\n        resizedCoords: {}\n    };\n    //Create default line object\n    lineObject = {\n        type: \"line\",\n        path: new Path2D(),\n        resizedPath: null,\n        lineWidth: 5,\n        strokeStyle: \"black\",\n        operation: \"source-over\",\n        coords: {},\n        resizedCoords: {}\n    };\n    drawingData = [];\n    startX = 0;\n    startY = 0;\n    mouseX = 0;\n    mouseY = 0;\n    selectedTool = {};\n    constructor(elementId, options){\n        //Select canvas element\n        const canvas = document.getElementById(elementId);\n        const context = canvas.getContext(\"2d\");\n        options?.elements?.forEach((element)=>{\n            //Assign each element passed to options to its correct place\n            (0, $cca413c873b82bf5$export$6aa9081c568366ea)(element, this.tools);\n            (0, $cca413c873b82bf5$export$6aa9081c568366ea)(element, this.toolModifiers);\n            (0, $cca413c873b82bf5$export$6aa9081c568366ea)(element, this.canvasModifiers);\n        });\n        //Check if width and height has been set\n        options?.width ? canvas.width = options.width : canvas.width = window.innerWidth - canvas.offsetLeft;\n        options?.height ? canvas.height = options.height : canvas.height = window.innerHeight - canvas.offsetTop;\n        //Save canvas and context in class\n        this.canvas = canvas;\n        this.context = context;\n        //Assign default values\n        this.canvas.style.cursor = \"crosshair\";\n        //Set selected tool as pencil if exists\n        this.tools.pencil && (this.selectedTool.element = this.tools.pencil, this.selectedTool.name = \"pencil\");\n        this.selectedTool.element?.classList.add(\"active\");\n        this.activeTools[this.selectedTool.name] = true;\n        //Add eventlisteners to canvas\n        this.listen();\n    }\n    //Listen for events and call correct function\n    listen() {\n        const canvas = this.canvas;\n        const controller = this.controller;\n        canvas.addEventListener(\"mousedown\", this.pressDownHandler);\n        canvas.addEventListener(\"mouseup\", this.mouseUpHandler);\n        canvas.addEventListener(\"mousemove\", this.mouseMoveHandler);\n        canvas.addEventListener(\"touchstart\", this.pressDownHandler);\n        canvas.addEventListener(\"touchend\", this.mouseUpHandler);\n        canvas.addEventListener(\"touchmove\", this.mouseMoveHandler);\n        controller?.addEventListener(\"change\", this.changeHandler);\n        controller?.addEventListener(\"click\", this.toolSelectHandler);\n    }\n    //Controller Change handler\n    changeHandler = (e)=>{\n        const target = e.target;\n        const colorPicker = this.toolModifiers.color;\n        const lineWidthPicker = this.toolModifiers.width;\n        if (colorPicker && this.targetIs(colorPicker, target)) //Change current path object strokeStyle\n        this.pathObject.strokeStyle = target.value;\n        if (lineWidthPicker && this.targetIs(lineWidthPicker, target)) this.pathObject.lineWidth = Number(target.value);\n    };\n    //Controller click handler\n    toolSelectHandler = (e)=>{\n        this.selectedDrawingIndex = null;\n        const target = e.target;\n        const context = this.context;\n        //Filter out nullish value props\n        const definedTools = (0, $cca413c873b82bf5$export$e3c872aa2ab87149)(this.tools);\n        const definedCanvasModifiers = (0, $cca413c873b82bf5$export$e3c872aa2ab87149)(this.canvasModifiers);\n        if (Object.keys(definedTools).length > 0) {\n            //Loop each defined element and check which of them are the target\n            Object.entries(definedTools).forEach(([k, v])=>{\n                //IF tool is target\n                if (v === target) {\n                    //Store tool name and element as selected\n                    this.selectedTool.element = v;\n                    this.selectedTool.name = k;\n                } else {\n                    this.activeTools[k] = false;\n                    v?.classList.remove(\"active\");\n                }\n            });\n            //Add active class for the selected tool and update activeTools object\n            this.selectedTool.element?.classList.add(\"active\");\n            this.activeTools[this.selectedTool.name] = true;\n            //Set correct cursor based on selectedTool\n            this.selectedTool.name === \"pencil\" || this.selectedTool.name === \"eraser\" || this.selectedTool.name === \"line\" ? this.canvas.style.cursor = \"crosshair\" : this.selectedTool.name === \"text\" ? this.canvas.style.cursor = \"text\" : this.canvas.style.cursor = \"default\";\n        }\n        if (Object.keys(definedCanvasModifiers).length > 0) {\n            if (definedCanvasModifiers.clear === target) {\n                context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                this.index = -1;\n                this.drawingData = [];\n            }\n            if (definedCanvasModifiers.undo === target) {\n                if (this.index <= 0) {\n                    context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                    this.index = -1;\n                    this.drawingData = [];\n                } else {\n                    this.index -= 1;\n                    this.drawingData.pop();\n                    this.redraw(this.drawingData);\n                }\n            }\n        }\n    };\n    //Handles pressdown/click\n    pressDownHandler = (e)=>{\n        this.mouseIsDown = true;\n        if (this.actions.writing) return;\n        //Check if event is touch or mouse\n        const evtType = e.touches ? e.touches[0] : e;\n        const { pencil: pencil, eraser: eraser, moveAndResize: moveAndResize, text: text, line: line } = this.activeTools;\n        const mouseY = evtType.clientY - this.canvas.offsetTop;\n        const mouseX = evtType.clientX - this.canvas.offsetLeft;\n        //Store starting positions\n        this.startX = mouseX;\n        this.startY = mouseY;\n        //IF eraser is the active tool\n        if (eraser) {\n            this.pathObject.operation = \"destination-out\";\n            this.shouldErase = true;\n            this.addCoords(mouseX, mouseY, false);\n        }\n        if (pencil) {\n            this.pathObject.operation = \"source-over\";\n            this.shouldDraw = true;\n            this.addCoords(mouseX, mouseY, false);\n        }\n        if (moveAndResize) {\n            //IF no paths\n            if (this.drawingData.length <= 0) return;\n            //IF there already is a selected drawing\n            if (this.selectedDrawingIndex !== null) {\n                const selected = this.drawingData[this.selectedDrawingIndex];\n                //Get position of mouse within drawing\n                const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, selected);\n                //IF mouse is not in drawing anymore\n                if (!selectionPosition) //Disselect the selected\n                this.selectedDrawingIndex = null;\n                else //IF mouse is inside the selection THEN check if move or resize\n                selectionPosition === \"middle\" ? this.shouldMove = true : (this.shouldResize.toggled = true, this.shouldResize.from = selectionPosition);\n            }\n            //Loop through each drawing and check if one has been clicked on and set that as the selected drawing\n            this.drawingData.forEach((drawing, i)=>{\n                if (drawing.type === \"stroke\" || drawing.type === \"line\") //Mouse is inside stroke\n                {\n                    if (this.context.isPointInStroke(drawing.path, mouseX, mouseY)) {\n                        //Set selected drawing\n                        this.selectedDrawingIndex = i;\n                        const selected = this.drawingData[this.selectedDrawingIndex];\n                        //Then check mouse position if we should resize or move\n                        const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, selected);\n                        selectionPosition === \"middle\" ? this.shouldMove = true : (this.shouldResize.toggled = true, this.shouldResize.from = selectionPosition);\n                    }\n                } else if (this.mouseWithinSelection(mouseX, mouseY, drawing)) {\n                    this.selectedDrawingIndex = i;\n                    const selected = this.drawingData[this.selectedDrawingIndex];\n                    const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, selected);\n                    selectionPosition === \"middle\" ? this.shouldMove = true : (this.shouldResize.toggled = true, this.shouldResize.from = selectionPosition);\n                }\n            });\n        }\n        if (text) {\n            const canvasContainer = document.querySelector(\".drawing-board\");\n            //Create textinput\n            const textInput = (0, $cca413c873b82bf5$export$6d5a273f7a8fcfca)(\"input\", canvasContainer, {\n                position: \"fixed\",\n                top: `${evtType.clientY}px`,\n                left: `${evtType.clientX}px`,\n                outline: \"none\",\n                background: \"none\",\n                border: \"none\",\n                \"font-size\": \"30pt\",\n                \"font-family\": \"sans-serif\"\n            });\n            //We are now writing\n            this.actions.writing = true;\n            //Focus input\n            window.setTimeout(()=>textInput.focus(), 0);\n            //Runs whenever we unfocus input\n            textInput.addEventListener(\"blur\", ()=>{\n                this.redraw(this.drawingData);\n                //Store value of text in drawing for later refernce when drawing it\n                this.textObject.text = textInput.value;\n                //Set context props based on current drawing\n                this.setCtxStyles(this.textObject);\n                //Measure the drawn text\n                const textWidth = this.context.measureText(textInput.value).width;\n                const textHeight = parseInt(this.context.font);\n                //Init coordinates\n                this.textObject.coords = {\n                    x1: mouseX,\n                    y1: mouseY,\n                    x2: Math.round(mouseX + textWidth),\n                    y2: Math.round(mouseY + textHeight)\n                };\n                //Draw the text\n                this.context.fillText(this.textObject.text, mouseX, mouseY);\n                //Save and store index\n                this.index = (0, $cca413c873b82bf5$export$c60994988c361040)(this.index, \"increment\", 1);\n                this.drawingData.push(this.textObject);\n                canvasContainer.removeChild(textInput);\n                this.actions.writing = false;\n                //Set new text object\n                this.textObject = {\n                    type: \"text\",\n                    text: \"\",\n                    font: \"30pt sans-serif\",\n                    resizedFont: \"\",\n                    baseline: \"top\",\n                    operation: \"source-over\",\n                    coords: {},\n                    resizedCoords: {}\n                };\n            });\n            textInput.addEventListener(\"keypress\", (e)=>{\n                if (e.key === \"Enter\") textInput.blur();\n            });\n            canvasContainer?.appendChild(textInput);\n        }\n        if (line) {\n            if (this.actions.lining) return; //So it jumps to mouseup\n            this.lineObject.operation = \"source-over\";\n            //Signal that we are trying to draw a line\n            this.shouldLine = true;\n            this.lineObject.path.moveTo(mouseX, mouseY);\n            //Init start coordinates\n            this.lineObject.coords = {\n                startX: mouseX,\n                startY: mouseY\n            };\n        }\n    };\n    //Handles mouse release\n    mouseUpHandler = ()=>{\n        //Reset states\n        this.mouseIsDown = false;\n        this.shouldMove = false;\n        this.actions.moving = false;\n        if (this.actions.drawing || this.actions.erasing) {\n            this.shouldDraw = false;\n            this.shouldErase = false;\n            this.actions.drawing = false;\n            this.actions.erasing = false;\n            //IF its just a click and no stroke\n            if (this.pathObject.xCords.length === 1) {\n                this.pathObject = {\n                    type: \"stroke\",\n                    path: new Path2D(),\n                    resizedPath: null,\n                    lineWidth: this.context.lineWidth,\n                    strokeStyle: String(this.context.strokeStyle),\n                    operation: \"source-over\",\n                    coords: {},\n                    resizedCoords: {},\n                    xCords: [],\n                    yCords: [],\n                    resizedXCords: [],\n                    resizedYCords: []\n                };\n                return;\n            }\n            //Init coords\n            this.pathObject.coords = {\n                x1: Math.min(...this.pathObject.xCords),\n                y1: Math.min(...this.pathObject.yCords),\n                x2: Math.max(...this.pathObject.xCords),\n                y2: Math.max(...this.pathObject.yCords)\n            };\n            //Save\n            this.index = (0, $cca413c873b82bf5$export$c60994988c361040)(this.index, \"increment\", 1);\n            this.drawingData.push(this.pathObject);\n            //Set new pathObject\n            this.pathObject = {\n                type: \"stroke\",\n                path: new Path2D(),\n                resizedPath: null,\n                lineWidth: this.context.lineWidth,\n                strokeStyle: String(this.context.strokeStyle),\n                operation: \"source-over\",\n                coords: {},\n                resizedCoords: {},\n                xCords: [],\n                yCords: [],\n                resizedXCords: [],\n                resizedYCords: []\n            };\n        }\n        if (this.actions.resizing) {\n            this.shouldResize = {\n                toggled: false,\n                from: \"\"\n            };\n            this.actions.resizing = false;\n            if (this.selectedDrawingIndex !== null) {\n                const selectedDrawing = this.drawingData[this.selectedDrawingIndex];\n                this.updateToResized(selectedDrawing);\n            }\n        }\n        if (this.actions.lining) {\n            this.shouldLine = false;\n            this.actions.lining = false;\n            //Set end points\n            this.lineObject.coords.endX = this.mouseX;\n            this.lineObject.coords.endY = this.mouseY;\n            //Take the path and line it to end\n            this.lineObject.path.lineTo(this.mouseX, this.mouseY);\n            //Save new line\n            this.index = (0, $cca413c873b82bf5$export$c60994988c361040)(this.index, \"increment\", 1);\n            this.drawingData.push(this.lineObject);\n            //New lineObject\n            this.lineObject = {\n                type: \"line\",\n                path: new Path2D(),\n                resizedPath: null,\n                lineWidth: 5,\n                strokeStyle: \"black\",\n                operation: \"source-over\",\n                coords: {},\n                resizedCoords: {}\n            };\n        }\n        this.redraw(this.drawingData);\n    };\n    //Handles moving mouse\n    mouseMoveHandler = (e)=>{\n        const evtType = e.touches ? e.touches[0] : e;\n        //Current mouse positions\n        const mouseX = evtType.clientX - this.canvas.offsetLeft;\n        const mouseY = evtType.clientY - this.canvas.offsetTop;\n        //Store current mousePosition\n        this.mouseX = mouseX;\n        this.mouseY = mouseY;\n        this.mouseIsDown ? this.isDragging = true : this.isDragging = false;\n        // If move and resize tool is active\n        if (this.activeTools.moveAndResize) {\n            this.canvas.style.cursor = \"default\";\n            this.drawingData.forEach((drawing, i)=>{\n                switch(drawing.type){\n                    case \"stroke\":\n                        if (this.context.isPointInStroke(drawing.path, mouseX, mouseY)) this.canvas.style.cursor = \"move\";\n                        //IF we are hovering the selected drawing\n                        if (this.selectedDrawingIndex === i && this.mouseWithinSelection(mouseX, mouseY, drawing)) {\n                            //Get position within selection\n                            const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, drawing);\n                            //Style accordingly\n                            selectionPosition === \"middle\" ? this.canvas.style.cursor = \"move\" : selectionPosition === \"top-left\" || selectionPosition === \"bottom-right\" ? this.canvas.style.cursor = \"nwse-resize\" : this.canvas.style.cursor = \"nesw-resize\";\n                        }\n                        break;\n                    case \"text\":\n                        if (this.mouseWithinSelection(mouseX, mouseY, drawing)) {\n                            const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, drawing);\n                            selectionPosition === \"middle\" ? this.canvas.style.cursor = \"move\" : selectionPosition === \"top-left\" || selectionPosition === \"bottom-right\" ? this.canvas.style.cursor = \"nwse-resize\" : this.canvas.style.cursor = \"nesw-resize\";\n                        }\n                        break;\n                    case \"line\":\n                        if (this.mouseWithinSelection(mouseX, mouseY, drawing)) {\n                            const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, drawing);\n                            selectionPosition === \"middle\" ? this.canvas.style.cursor = \"move\" : this.canvas.style.cursor = \"pointer\";\n                        }\n                        break;\n                }\n            });\n        }\n        //IF we have a selected drawing and we are dragging\n        if (this.selectedDrawingIndex !== null && this.isDragging) {\n            //Move with respect to current mouse\n            const dx = mouseX - this.startX;\n            const dy = mouseY - this.startY;\n            //Selected drawing\n            const selectedDrawing = this.drawingData[this.selectedDrawingIndex];\n            //Coords are required IF not present then throw an error\n            (0, $cca413c873b82bf5$export$953570f03e48e201)(selectedDrawing.coords);\n            switch(selectedDrawing.type){\n                case \"stroke\":\n                    if (this.shouldMove) {\n                        this.actions.moving = true;\n                        //Update x and y coordinates\n                        for(let i = 0; i < selectedDrawing.xCords.length; i++){\n                            selectedDrawing.xCords[i] += dx;\n                            selectedDrawing.yCords[i] += dy;\n                        }\n                        //Update left, top, right and bottom\n                        selectedDrawing.coords.x1 = Math.min(...selectedDrawing.xCords);\n                        selectedDrawing.coords.y1 = Math.min(...selectedDrawing.yCords);\n                        selectedDrawing.coords.x2 = Math.max(...selectedDrawing.xCords);\n                        selectedDrawing.coords.y2 = Math.max(...selectedDrawing.yCords);\n                        //Create new path from existing path\n                        const newPath = new Path2D();\n                        const m = new DOMMatrix().translate(dx, dy);\n                        newPath.addPath(selectedDrawing.path, m);\n                        selectedDrawing.path = newPath;\n                        //Set start positions to current\n                        this.startX = mouseX;\n                        this.startY = mouseY;\n                    } else {\n                        const from = this.shouldResize.from;\n                        this.actions.resizing = true;\n                        const { scaleOriginXPos: scaleOriginXPos, scaleOriginYPos: scaleOriginYPos, scale: scale } = this.getScaleInfo(from, selectedDrawing, mouseX, mouseY);\n                        const scaleOriginX = scaleOriginXPos;\n                        const scaleOriginY = scaleOriginYPos;\n                        const scaleFactor = scale;\n                        const resizedPath = new Path2D();\n                        //Create copy\n                        const resizedXCords = [\n                            ...selectedDrawing.xCords\n                        ];\n                        const resizedYCords = [\n                            ...selectedDrawing.yCords\n                        ];\n                        const originalDistanceX = [];\n                        const originalDistanceY = [];\n                        //Calculate original distance between origin and x,y coordinates\n                        for(let i = 0; i < selectedDrawing.xCords.length; i++){\n                            originalDistanceX[i] = scaleOriginX - selectedDrawing.xCords[i];\n                            originalDistanceY[i] = scaleOriginY - selectedDrawing.yCords[i];\n                        }\n                        //Update to resized coords\n                        for(let i = 0; i < resizedXCords.length; i++){\n                            //Calculate new distance based on scale factor\n                            const newDistanceX = originalDistanceX[i] * scaleFactor;\n                            const newDistanceY = originalDistanceY[i] * scaleFactor;\n                            //Place resized coords in the correct place\n                            resizedXCords[i] = scaleOriginX - newDistanceX;\n                            resizedYCords[i] = scaleOriginY - newDistanceY;\n                            //Move path to new coords\n                            resizedPath.moveTo(resizedXCords[i - 1], resizedYCords[i - 1]);\n                            //Create line to new coords\n                            resizedPath.lineTo(resizedXCords[i], resizedYCords[i]);\n                        }\n                        //Set resized left, right, top and bottom\n                        selectedDrawing.resizedCoords.resizedX1 = Math.min(...resizedXCords);\n                        selectedDrawing.resizedCoords.resizedY1 = Math.min(...resizedYCords);\n                        selectedDrawing.resizedCoords.resizedX2 = Math.max(...resizedXCords);\n                        selectedDrawing.resizedCoords.resizedY2 = Math.max(...resizedYCords);\n                        selectedDrawing.resizedXCords = resizedXCords;\n                        selectedDrawing.resizedYCords = resizedYCords;\n                        selectedDrawing.resizedPath = resizedPath;\n                    }\n                    break;\n                case \"text\":\n                    if (this.shouldMove) {\n                        this.actions.moving = true;\n                        //Assign new coordinates\n                        selectedDrawing.coords.x1 += dx;\n                        selectedDrawing.coords.y1 += dy;\n                        selectedDrawing.coords.x2 += dx;\n                        selectedDrawing.coords.y2 += dy;\n                        this.startX = mouseX;\n                        this.startY = mouseY;\n                    } else {\n                        const from = this.shouldResize.from;\n                        this.actions.resizing = true;\n                        const { scaleOriginXPos: scaleOriginXPos, scaleOriginYPos: scaleOriginYPos, startCornerXPos: startCornerXPos, startCornerYPos: startCornerYPos, scale: scale } = this.getScaleInfo(from, selectedDrawing, mouseX, mouseY);\n                        const startCornerX = startCornerXPos;\n                        const startCornerY = startCornerYPos;\n                        const scaleOriginX = scaleOriginXPos;\n                        const scaleOriginY = scaleOriginYPos;\n                        //Scale factor based on mouse\n                        const scaleFactor = scale;\n                        //Create copy of original font string\n                        const fontStringCopy = selectedDrawing.font.slice();\n                        //Convert font size to number/float\n                        const fontSize = parseFloat(fontStringCopy);\n                        //Get original distance from scale origin to start corner/current mouse\n                        const originalDistanceX = scaleOriginX - startCornerX;\n                        const originalDistanceY = scaleOriginY - startCornerY;\n                        //Resize font size\n                        const resizedFontSize = fontSize * scaleFactor;\n                        //Get new distance based on scale factor\n                        const newDistanceX = originalDistanceX * scaleFactor;\n                        const newDistanceY = originalDistanceY * scaleFactor;\n                        //Replace original font size with resized\n                        const newFont = fontStringCopy.replace(fontSize.toString(), resizedFontSize.toString());\n                        //Store new left and right\n                        if (from === \"top-left\" || from === \"bottom-left\") {\n                            selectedDrawing.resizedCoords.resizedX1 = scaleOriginX - newDistanceX;\n                            selectedDrawing.resizedCoords.resizedX2 = scaleOriginX;\n                        } else {\n                            selectedDrawing.resizedCoords.resizedX1 = scaleOriginX;\n                            selectedDrawing.resizedCoords.resizedX2 = scaleOriginX - newDistanceX;\n                        }\n                        //Store new top and bottom\n                        if (from === \"top-left\" || from === \"top-right\") {\n                            selectedDrawing.resizedCoords.resizedY1 = scaleOriginY - newDistanceY;\n                            selectedDrawing.resizedCoords.resizedY2 = scaleOriginY;\n                        } else {\n                            selectedDrawing.resizedCoords.resizedY1 = scaleOriginY;\n                            selectedDrawing.resizedCoords.resizedY2 = scaleOriginY - newDistanceY;\n                        }\n                        //Store the new font size\n                        selectedDrawing.resizedFont = newFont;\n                    }\n                    break;\n                case \"line\":\n                    if (this.shouldMove) {\n                        this.actions.moving = true;\n                        //Assign new start and end coordinates\n                        selectedDrawing.coords.startX += dx;\n                        selectedDrawing.coords.startY += dy;\n                        selectedDrawing.coords.endX += dx;\n                        selectedDrawing.coords.endY += dy;\n                        //Create new path from existing path\n                        const newPath = new Path2D();\n                        const m = new DOMMatrix().translate(dx, dy);\n                        newPath.addPath(selectedDrawing.path, m);\n                        selectedDrawing.path = newPath;\n                        this.startX = mouseX;\n                        this.startY = mouseY;\n                    } else {\n                        const from = this.shouldResize.from;\n                        this.actions.resizing = true;\n                        const { scaleOriginXPos: scaleOriginXPos, scaleOriginYPos: scaleOriginYPos, startCornerXPos: startCornerXPos, startCornerYPos: startCornerYPos } = this.getScaleInfo(from, selectedDrawing, mouseX, mouseY);\n                        const resizedPath = new Path2D();\n                        const startCornerX = startCornerXPos;\n                        const startCornerY = startCornerYPos;\n                        const scaleOriginX = scaleOriginXPos;\n                        const scaleOriginY = scaleOriginYPos;\n                        //Assign start and end x\n                        if (startCornerX === selectedDrawing.coords.startX) {\n                            selectedDrawing.resizedCoords.resizedStartX = mouseX;\n                            selectedDrawing.resizedCoords.resizedEndX = scaleOriginX;\n                        } else {\n                            selectedDrawing.resizedCoords.resizedStartX = scaleOriginX;\n                            selectedDrawing.resizedCoords.resizedEndX = mouseX;\n                        }\n                        //Assign start and end y\n                        if (startCornerY === selectedDrawing.coords.startY) {\n                            selectedDrawing.resizedCoords.resizedStartY = mouseY;\n                            selectedDrawing.resizedCoords.resizedEndY = scaleOriginY;\n                        } else {\n                            selectedDrawing.resizedCoords.resizedStartY = scaleOriginY;\n                            selectedDrawing.resizedCoords.resizedEndY = mouseY;\n                        }\n                        this.context.beginPath();\n                        resizedPath.moveTo(mouseX, mouseY);\n                        resizedPath.lineTo(scaleOriginX, scaleOriginY);\n                        selectedDrawing.resizedPath = resizedPath;\n                    }\n                    break;\n            }\n            this.redraw(this.drawingData);\n        }\n        if (this.shouldDraw && this.isDragging || this.shouldErase && this.isDragging) {\n            this.shouldDraw ? this.actions.drawing = true : this.actions.drawing = false;\n            this.shouldErase ? this.actions.erasing = true : this.actions.erasing = false;\n            this.redraw(this.drawingData);\n            //Set props for current path object\n            this.setCtxStyles(this.pathObject);\n            this.addCoords(mouseX, mouseY, true);\n            this.pathObject.path.lineTo(mouseX, mouseY);\n            this.context.stroke(this.pathObject.path);\n        }\n        if (this.shouldLine) {\n            this.actions.lining = true;\n            //Redraw data\n            this.redraw(this.drawingData);\n            this.setCtxStyles(this.lineObject);\n            //Begin current path\n            this.context.beginPath();\n            //Move context to start position of lineObject\n            this.context.moveTo(this.lineObject.coords.startX, this.lineObject.coords.startY); //We know that since we \"shouldLine\" we have clicked so we can say as\n            //Draw a line to current mouse position\n            this.context.lineTo(mouseX, mouseY);\n            //Close the path and save -> repeat while moving\n            this.context.closePath();\n            this.context.stroke();\n        }\n        e.preventDefault();\n    };\n    //Function that updates given drawings coords to resized coords\n    updateToResized(drawing) {\n        if (drawing.type === \"stroke\") {\n            drawing.xCords = drawing.resizedXCords;\n            drawing.yCords = drawing.resizedYCords;\n            drawing.coords.x1 = Math.min(...drawing.xCords);\n            drawing.coords.y1 = Math.min(...drawing.yCords);\n            drawing.coords.x2 = Math.max(...drawing.xCords);\n            drawing.coords.y2 = Math.max(...drawing.yCords);\n            drawing.path = drawing.resizedPath;\n        } else if (drawing.type === \"text\") {\n            drawing.coords.x1 = drawing.resizedCoords.resizedX1;\n            drawing.coords.y1 = drawing.resizedCoords.resizedY1;\n            drawing.coords.x2 = drawing.resizedCoords.resizedX2;\n            drawing.coords.y2 = drawing.resizedCoords.resizedY2;\n            drawing.font = drawing.resizedFont;\n        } else {\n            drawing.coords.startX = drawing.resizedCoords.resizedStartX;\n            drawing.coords.endX = drawing.resizedCoords.resizedEndX;\n            drawing.coords.startY = drawing.resizedCoords.resizedStartY;\n            drawing.coords.endY = drawing.resizedCoords.resizedEndY;\n            drawing.path = drawing.resizedPath;\n        }\n    }\n    //Adds each coordinate to array\n    addCoords(x, y, dragging) {\n        this.pathObject.xCords.push(x);\n        this.pathObject.yCords.push(y);\n        this.isDragging = dragging;\n    }\n    //Function that returns correct coordinates and scalefactor for scaling\n    getScaleInfo(from, element, currentMouseX, currentMouseY) {\n        (0, $cca413c873b82bf5$export$953570f03e48e201)(element.coords);\n        if (element.type === \"line\") {\n            const startCornerX = from === \"start\" ? element.coords.startX : element.coords.endX;\n            const startCornerY = from === \"start\" ? element.coords.startY : element.coords.endY;\n            const scaleOriginX = from === \"start\" ? element.coords.endX : element.coords.startX;\n            const scaleOriginY = from === \"start\" ? element.coords.endY : element.coords.startY;\n            return {\n                scaleOriginXPos: scaleOriginX,\n                scaleOriginYPos: scaleOriginY,\n                startCornerXPos: startCornerX,\n                startCornerYPos: startCornerY,\n                scale: 0\n            };\n        } else {\n            //IF scaling from the left side then start = left : start = right;\n            const startCornerX = from.includes(\"left\") ? element.coords.x1 : element.coords.x2;\n            const startCornerY = from.includes(\"top\") ? element.coords.y1 : element.coords.y2;\n            //IF scaling from left side then origin is opposite side so that we scale inwards or outwards based on corner\n            const scaleOriginX = from.includes(\"left\") ? element.coords.x2 : element.coords.x1;\n            const scaleOriginY = from.includes(\"top\") ? element.coords.y2 : element.coords.y1;\n            //For the scaling to work properly i also need where we scale from\n            //Since scaling from left side to right side would not work with e.g (x1 - x2 so instead x2 - x1 for distance)\n            const originalDistance = from.includes(\"left\") ? scaleOriginX - startCornerX : startCornerX - scaleOriginX + (from.includes(\"top\") ? scaleOriginY - startCornerY : startCornerY - scaleOriginY);\n            const currentDistance = from.includes(\"left\") ? scaleOriginX - currentMouseX : currentMouseX - scaleOriginX + (from.includes(\"top\") ? scaleOriginY - currentMouseY : currentMouseY - scaleOriginY);\n            const scaleFactor = currentDistance / originalDistance;\n            return {\n                scaleOriginXPos: scaleOriginX,\n                scaleOriginYPos: scaleOriginY,\n                startCornerXPos: startCornerX,\n                startCornerYPos: startCornerY,\n                scale: scaleFactor\n            };\n        }\n    }\n    //Checks if mouse is within selection rectangle for those that have it\n    mouseWithinSelection(x, y, drawing) {\n        (0, $cca413c873b82bf5$export$953570f03e48e201)(drawing.coords);\n        let mouseIsIn;\n        //Fine if its close enough\n        const offset = 10;\n        if (drawing.type === \"line\") {\n            const { startX: startX, endX: endX, startY: startY, endY: endY } = drawing.coords;\n            const startX1 = startX - offset;\n            const startX2 = startX + offset;\n            const startY1 = startY - offset;\n            const startY2 = startY + offset;\n            const endX1 = endX - offset;\n            const endX2 = endX + offset;\n            const endY1 = endY - offset;\n            const endY2 = endY + offset;\n            mouseIsIn = this.mouseWithin(startX1, startX2, startY1, startY2, x, y) ? \"start\" : this.mouseWithin(endX1, endX2, endY1, endY2, x, y) ? \"end\" : this.context.isPointInStroke(drawing.path, x, y) ? \"middle\" : \"\";\n        } else {\n            const { x1: x1, y1: y1, x2: x2, y2: y2 } = drawing.coords;\n            //Top left rectangle\n            const topLeftX1 = x1 - offset;\n            const topLeftX2 = x1 + offset;\n            const topLeftY1 = y1 - offset;\n            const topLeftY2 = y1 + offset;\n            //Top right rectangle\n            const topRightX1 = x2 - offset;\n            const topRightX2 = x2 + offset;\n            const topRightY1 = y1 - offset;\n            const topRightY2 = y1 + offset;\n            //Bottom right rectangle\n            const bottomRightX1 = x2 - offset;\n            const bottomRightX2 = x2 + offset;\n            const bottomRightY1 = y2 - offset;\n            const bottomRightY2 = y2 + offset;\n            //Bottom left rectangle\n            const bottomLeftX1 = x1 - offset;\n            const bottomLeftX2 = x1 + offset;\n            const bottomLeftY1 = y2 - offset;\n            const bottomLeftY2 = y2 + offset;\n            mouseIsIn = this.mouseWithin(topLeftX1, topLeftX2, topLeftY1, topLeftY2, x, y) ? \"top-left\" : this.mouseWithin(topRightX1, topRightX2, topRightY1, topRightY2, x, y) ? \"top-right\" : this.mouseWithin(bottomRightX1, bottomRightX2, bottomRightY1, bottomRightY2, x, y) ? \"bottom-right\" : this.mouseWithin(bottomLeftX1, bottomLeftX2, bottomLeftY1, bottomLeftY2, x, y) ? \"bottom-left\" : this.mouseWithin(x1, x2, y1, y2, x, y) ? \"middle\" : \"\";\n        }\n        return mouseIsIn;\n    }\n    //Function for well.. creating a drawing selection\n    createDrawingSelection(drawing) {\n        this.context.globalCompositeOperation = \"source-over\";\n        this.context.strokeStyle = \"#738FE5\";\n        this.context.lineWidth = 1;\n        if (drawing.type === \"stroke\" || drawing.type === \"text\") {\n            const coords = (0, $9403128a2a74c1da$export$bf395ed26c12da18)(drawing, this.actions.resizing);\n            const width = coords.x2 - coords.x1;\n            const height = coords.y2 - coords.y1;\n            //Draw main rectangle\n            this.context.strokeRect(coords.x1, coords.y1, width, height);\n            //Draw corners\n            this.drawCornerPoints(drawing);\n        } else {\n            const coords = (0, $9403128a2a74c1da$export$bf395ed26c12da18)(drawing, this.actions.resizing);\n            //Draw line from start to end\n            this.context.lineWidth = 1;\n            this.context.moveTo(coords.startX, coords.startY);\n            this.context.lineTo(coords.endX, coords.endY);\n            this.context.stroke();\n            this.drawCornerPoints(drawing);\n        }\n    }\n    //Function for drawing corner points :P\n    drawCornerPoints(drawing) {\n        this.context.lineWidth = 5;\n        let x;\n        let y;\n        if (drawing.type === \"stroke\" || drawing.type === \"text\") {\n            const coords = (0, $9403128a2a74c1da$export$bf395ed26c12da18)(drawing, this.actions.resizing);\n            //Selection has 4 corners\n            for(let i = 0; i < 4; i++){\n                i === 0 ? (x = coords.x1, y = coords.y1 //First draw top left corner\n                ) : i === 1 ? (x = coords.x2, y = coords.y1 //Second draw top right corner\n                ) : i === 2 ? (x = coords.x1, y = coords.y2 //Third draw bottom left corner\n                ) : (x = coords.x2, y = coords.y2); //Last draw bottom right corner\n                this.context.beginPath();\n                this.context.arc(x, y, 1, 0, 2 * Math.PI);\n                this.context.stroke();\n            }\n        } else {\n            const coords = (0, $9403128a2a74c1da$export$bf395ed26c12da18)(drawing, this.actions.resizing);\n            //Selection has 2 ends\n            for(let i = 0; i < 2; i++){\n                i === 0 ? (x = coords.startX, y = coords.startY) : (x = coords.endX, y = coords.endY);\n                this.context.beginPath();\n                this.context.arc(x, y, 1, 0, 2 * Math.PI);\n                this.context.stroke();\n            }\n        }\n    }\n    //Checks if mouse is within given coordinates\n    mouseWithin(x1, x2, y1, y2, x, y) {\n        if (x >= x1 && x <= x2 && y >= y1 && y <= y2) return true;\n        return false;\n    }\n    //Function for setting styles based on drawing\n    setCtxStyles(drawing) {\n        this.context.globalCompositeOperation = drawing.operation;\n        this.context.lineCap = \"round\";\n        if (drawing.type === \"stroke\" || drawing.type === \"line\") {\n            this.context.lineWidth = drawing.lineWidth;\n            this.context.strokeStyle = drawing.strokeStyle;\n        } else if (drawing.type === \"text\") {\n            this.context.textBaseline = drawing.baseline;\n            this.context.font = drawing.font;\n        }\n    }\n    //Function for redrawing canvas when interactive\n    redraw(drawingData) {\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (drawingData.length <= 0) return;\n        drawingData.forEach((drawing, i)=>{\n            switch(drawing.type){\n                case \"stroke\":\n                    if (this.selectedDrawingIndex === i) {\n                        if (this.actions.resizing) {\n                            this.setCtxStyles(drawing);\n                            this.context.stroke(drawing.resizedPath);\n                            this.createDrawingSelection(drawing);\n                            return;\n                        }\n                        this.createDrawingSelection(drawing);\n                    }\n                    this.setCtxStyles(drawing);\n                    this.context.stroke(drawing.path);\n                    break;\n                case \"text\":\n                    if (this.selectedDrawingIndex === i) {\n                        if (this.actions.resizing) {\n                            (0, $cca413c873b82bf5$export$953570f03e48e201)(drawing.resizedCoords);\n                            this.setCtxStyles(drawing);\n                            this.context.font = drawing.resizedFont;\n                            this.context.fillText(drawing.text, drawing.resizedCoords.resizedX1, drawing.resizedCoords.resizedY1);\n                            this.createDrawingSelection(drawing);\n                            return;\n                        }\n                        this.createDrawingSelection(drawing);\n                    }\n                    this.setCtxStyles(drawing);\n                    this.context.fillText(drawing.text, drawing.coords.x1, drawing.coords.y1);\n                    break;\n                case \"line\":\n                    if (this.selectedDrawingIndex === i) {\n                        if (this.actions.resizing) {\n                            this.setCtxStyles(drawing);\n                            this.context.stroke(drawing.resizedPath);\n                            this.createDrawingSelection(drawing);\n                            return;\n                        }\n                    }\n                    this.setCtxStyles(drawing);\n                    this.context.stroke(drawing.path);\n                    if (this.selectedDrawingIndex === i) this.createDrawingSelection(drawing);\n                    break;\n            }\n        });\n    }\n    //Function that checks if given element is target\n    targetIs(element, target) {\n        if (target.id && target.id === element.id || target.className && target.className === element.className) return true;\n        else return false;\n    }\n}\nnew $44f51f21f2de7984$var$DrawingCanvas(\"drawing-board\");\n\n\n//# sourceMappingURL=index.202fbc4e.js.map\n","import { excludeNullishProps, assignCorrectly, assertRequired, incOrDec, createPersonalElement, } from \"./utils/common.js\";\nimport { getCorrectCoords } from \"./utils/overloads.js\";\nclass DrawingCanvas {\n    canvas;\n    context;\n    controller = document.getElementById(\"toolbar\");\n    //Base tools\n    tools = {\n        pencil: document.getElementById(\"pencil\"),\n        eraser: document.getElementById(\"eraser\"),\n        moveAndResize: document.getElementById(\"mv-rz\"),\n        text: document.getElementById(\"text\"),\n        line: document.getElementById(\"line\"),\n    };\n    //Tools for changing state of tools\n    toolModifiers = {\n        color: document.getElementById(\"color\"),\n        width: document.getElementById(\"lineWidth\"),\n    };\n    //Tools for changing state of Canvas\n    canvasModifiers = {\n        clear: document.getElementById(\"clear\"),\n        undo: document.getElementById(\"undo\"),\n    };\n    //For state tracking\n    actions = {\n        drawing: false,\n        erasing: false,\n        moving: false,\n        resizing: false,\n        writing: false,\n        lining: false,\n    };\n    shouldDraw = false;\n    shouldErase = false;\n    shouldMove = false;\n    shouldResize = {\n        toggled: false,\n        from: \"\",\n    };\n    shouldLine = false;\n    activeTools = {\n        pencil: false,\n        eraser: false,\n        moveAndResize: false,\n        text: false,\n        line: false,\n    };\n    mouseIsDown = false;\n    isDragging = false;\n    index = -1;\n    selectedDrawingIndex = null;\n    //Create default path object\n    pathObject = {\n        type: \"stroke\",\n        path: new Path2D(),\n        resizedPath: null,\n        lineWidth: 5,\n        strokeStyle: \"black\",\n        operation: \"source-over\",\n        coords: {},\n        resizedCoords: {},\n        xCords: [],\n        yCords: [],\n        resizedXCords: [],\n        resizedYCords: [],\n    };\n    //Create default text object\n    textObject = {\n        type: \"text\",\n        text: \"\",\n        font: \"30pt sans-serif\",\n        resizedFont: \"\",\n        baseline: \"top\",\n        operation: \"source-over\",\n        coords: {},\n        resizedCoords: {},\n    };\n    //Create default line object\n    lineObject = {\n        type: \"line\",\n        path: new Path2D(),\n        resizedPath: null,\n        lineWidth: 5,\n        strokeStyle: \"black\",\n        operation: \"source-over\",\n        coords: {},\n        resizedCoords: {},\n    };\n    drawingData = [];\n    startX = 0;\n    startY = 0;\n    mouseX = 0;\n    mouseY = 0;\n    selectedTool = {};\n    constructor(elementId, options) {\n        //Select canvas element\n        const canvas = document.getElementById(elementId);\n        const context = canvas.getContext(\"2d\");\n        options?.elements?.forEach((element) => {\n            //Assign each element passed to options to its correct place\n            assignCorrectly(element, this.tools);\n            assignCorrectly(element, this.toolModifiers);\n            assignCorrectly(element, this.canvasModifiers);\n        });\n        //Check if width and height has been set\n        options?.width\n            ? (canvas.width = options.width)\n            : (canvas.width = window.innerWidth - canvas.offsetLeft);\n        options?.height\n            ? (canvas.height = options.height)\n            : (canvas.height = window.innerHeight - canvas.offsetTop);\n        //Save canvas and context in class\n        this.canvas = canvas;\n        this.context = context;\n        //Assign default values\n        this.canvas.style.cursor = \"crosshair\";\n        //Set selected tool as pencil if exists\n        this.tools.pencil &&\n            ((this.selectedTool.element = this.tools.pencil), (this.selectedTool.name = \"pencil\"));\n        this.selectedTool.element?.classList.add(\"active\");\n        this.activeTools[this.selectedTool.name] = true;\n        //Add eventlisteners to canvas\n        this.listen();\n    }\n    //Listen for events and call correct function\n    listen() {\n        const canvas = this.canvas;\n        const controller = this.controller;\n        canvas.addEventListener(\"mousedown\", this.pressDownHandler);\n        canvas.addEventListener(\"mouseup\", this.mouseUpHandler);\n        canvas.addEventListener(\"mousemove\", this.mouseMoveHandler);\n        canvas.addEventListener(\"touchstart\", this.pressDownHandler);\n        canvas.addEventListener(\"touchend\", this.mouseUpHandler);\n        canvas.addEventListener(\"touchmove\", this.mouseMoveHandler);\n        controller?.addEventListener(\"change\", this.changeHandler);\n        controller?.addEventListener(\"click\", this.toolSelectHandler);\n    }\n    //Controller Change handler\n    changeHandler = (e) => {\n        const target = e.target;\n        const colorPicker = this.toolModifiers.color;\n        const lineWidthPicker = this.toolModifiers.width;\n        if (colorPicker && this.targetIs(colorPicker, target)) {\n            //Change current path object strokeStyle\n            this.pathObject.strokeStyle = target.value;\n        }\n        if (lineWidthPicker && this.targetIs(lineWidthPicker, target)) {\n            this.pathObject.lineWidth = Number(target.value);\n        }\n    };\n    //Controller click handler\n    toolSelectHandler = (e) => {\n        this.selectedDrawingIndex = null;\n        const target = e.target;\n        const context = this.context;\n        //Filter out nullish value props\n        const definedTools = excludeNullishProps(this.tools);\n        const definedCanvasModifiers = excludeNullishProps(this.canvasModifiers);\n        if (Object.keys(definedTools).length > 0) {\n            //Loop each defined element and check which of them are the target\n            Object.entries(definedTools).forEach(([k, v]) => {\n                //IF tool is target\n                if (v === target) {\n                    //Store tool name and element as selected\n                    this.selectedTool.element = v;\n                    this.selectedTool.name = k;\n                }\n                else {\n                    this.activeTools[k] = false;\n                    v?.classList.remove(\"active\");\n                }\n            });\n            //Add active class for the selected tool and update activeTools object\n            this.selectedTool.element?.classList.add(\"active\");\n            this.activeTools[this.selectedTool.name] = true;\n            //Set correct cursor based on selectedTool\n            this.selectedTool.name === \"pencil\" ||\n                this.selectedTool.name === \"eraser\" ||\n                this.selectedTool.name === \"line\"\n                ? (this.canvas.style.cursor = \"crosshair\")\n                : this.selectedTool.name === \"text\"\n                    ? (this.canvas.style.cursor = \"text\")\n                    : (this.canvas.style.cursor = \"default\");\n        }\n        if (Object.keys(definedCanvasModifiers).length > 0) {\n            if (definedCanvasModifiers.clear === target) {\n                context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                this.index = -1;\n                this.drawingData = [];\n            }\n            if (definedCanvasModifiers.undo === target) {\n                if (this.index <= 0) {\n                    context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                    this.index = -1;\n                    this.drawingData = [];\n                }\n                else {\n                    this.index -= 1;\n                    this.drawingData.pop();\n                    this.redraw(this.drawingData);\n                }\n            }\n        }\n    };\n    //Handles pressdown/click\n    pressDownHandler = (e) => {\n        this.mouseIsDown = true;\n        if (this.actions.writing)\n            return;\n        //Check if event is touch or mouse\n        const evtType = e.touches ? e.touches[0] : e;\n        const { pencil, eraser, moveAndResize, text, line } = this.activeTools;\n        const mouseY = evtType.clientY - this.canvas.offsetTop;\n        const mouseX = evtType.clientX - this.canvas.offsetLeft;\n        //Store starting positions\n        this.startX = mouseX;\n        this.startY = mouseY;\n        //IF eraser is the active tool\n        if (eraser) {\n            this.pathObject.operation = \"destination-out\";\n            this.shouldErase = true;\n            this.addCoords(mouseX, mouseY, false);\n        }\n        if (pencil) {\n            this.pathObject.operation = \"source-over\";\n            this.shouldDraw = true;\n            this.addCoords(mouseX, mouseY, false);\n        }\n        if (moveAndResize) {\n            //IF no paths\n            if (this.drawingData.length <= 0)\n                return;\n            //IF there already is a selected drawing\n            if (this.selectedDrawingIndex !== null) {\n                const selected = this.drawingData[this.selectedDrawingIndex];\n                //Get position of mouse within drawing\n                const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, selected);\n                //IF mouse is not in drawing anymore\n                if (!selectionPosition) {\n                    //Disselect the selected\n                    this.selectedDrawingIndex = null;\n                }\n                else {\n                    //IF mouse is inside the selection THEN check if move or resize\n                    selectionPosition === \"middle\"\n                        ? (this.shouldMove = true)\n                        : ((this.shouldResize.toggled = true),\n                            (this.shouldResize.from = selectionPosition));\n                }\n            }\n            //Loop through each drawing and check if one has been clicked on and set that as the selected drawing\n            this.drawingData.forEach((drawing, i) => {\n                if (drawing.type === \"stroke\" || drawing.type === \"line\") {\n                    //Mouse is inside stroke\n                    if (this.context.isPointInStroke(drawing.path, mouseX, mouseY)) {\n                        //Set selected drawing\n                        this.selectedDrawingIndex = i;\n                        const selected = this.drawingData[this.selectedDrawingIndex];\n                        //Then check mouse position if we should resize or move\n                        const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, selected);\n                        selectionPosition === \"middle\"\n                            ? (this.shouldMove = true)\n                            : ((this.shouldResize.toggled = true),\n                                (this.shouldResize.from = selectionPosition));\n                    }\n                }\n                else {\n                    if (this.mouseWithinSelection(mouseX, mouseY, drawing)) {\n                        this.selectedDrawingIndex = i;\n                        const selected = this.drawingData[this.selectedDrawingIndex];\n                        const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, selected);\n                        selectionPosition === \"middle\"\n                            ? (this.shouldMove = true)\n                            : ((this.shouldResize.toggled = true),\n                                (this.shouldResize.from = selectionPosition));\n                    }\n                }\n            });\n        }\n        if (text) {\n            const canvasContainer = document.querySelector(\".drawing-board\");\n            //Create textinput\n            const textInput = createPersonalElement(\"input\", canvasContainer, {\n                position: \"fixed\",\n                top: `${evtType.clientY}px`,\n                left: `${evtType.clientX}px`,\n                outline: \"none\",\n                background: \"none\",\n                border: \"none\",\n                \"font-size\": \"30pt\",\n                \"font-family\": \"sans-serif\",\n            });\n            //We are now writing\n            this.actions.writing = true;\n            //Focus input\n            window.setTimeout(() => textInput.focus(), 0);\n            //Runs whenever we unfocus input\n            textInput.addEventListener(\"blur\", () => {\n                this.redraw(this.drawingData);\n                //Store value of text in drawing for later refernce when drawing it\n                this.textObject.text = textInput.value;\n                //Set context props based on current drawing\n                this.setCtxStyles(this.textObject);\n                //Measure the drawn text\n                const textWidth = this.context.measureText(textInput.value).width;\n                const textHeight = parseInt(this.context.font);\n                //Init coordinates\n                this.textObject.coords = {\n                    x1: mouseX,\n                    y1: mouseY,\n                    x2: Math.round(mouseX + textWidth),\n                    y2: Math.round(mouseY + textHeight),\n                };\n                //Draw the text\n                this.context.fillText(this.textObject.text, mouseX, mouseY);\n                //Save and store index\n                this.index = incOrDec(this.index, \"increment\", 1);\n                this.drawingData.push(this.textObject);\n                canvasContainer.removeChild(textInput);\n                this.actions.writing = false;\n                //Set new text object\n                this.textObject = {\n                    type: \"text\",\n                    text: \"\",\n                    font: \"30pt sans-serif\",\n                    resizedFont: \"\",\n                    baseline: \"top\",\n                    operation: \"source-over\",\n                    coords: {},\n                    resizedCoords: {},\n                };\n            });\n            textInput.addEventListener(\"keypress\", (e) => {\n                if (e.key === \"Enter\") {\n                    textInput.blur();\n                }\n            });\n            canvasContainer?.appendChild(textInput);\n        }\n        if (line) {\n            if (this.actions.lining)\n                return; //So it jumps to mouseup\n            this.lineObject.operation = \"source-over\";\n            //Signal that we are trying to draw a line\n            this.shouldLine = true;\n            this.lineObject.path.moveTo(mouseX, mouseY);\n            //Init start coordinates\n            this.lineObject.coords = { startX: mouseX, startY: mouseY };\n        }\n    };\n    //Handles mouse release\n    mouseUpHandler = () => {\n        //Reset states\n        this.mouseIsDown = false;\n        this.shouldMove = false;\n        this.actions.moving = false;\n        if (this.actions.drawing || this.actions.erasing) {\n            this.shouldDraw = false;\n            this.shouldErase = false;\n            this.actions.drawing = false;\n            this.actions.erasing = false;\n            //IF its just a click and no stroke\n            if (this.pathObject.xCords.length === 1) {\n                this.pathObject = {\n                    type: \"stroke\",\n                    path: new Path2D(),\n                    resizedPath: null,\n                    lineWidth: this.context.lineWidth,\n                    strokeStyle: String(this.context.strokeStyle),\n                    operation: \"source-over\",\n                    coords: {},\n                    resizedCoords: {},\n                    xCords: [],\n                    yCords: [],\n                    resizedXCords: [],\n                    resizedYCords: [],\n                };\n                return;\n            }\n            //Init coords\n            this.pathObject.coords = {\n                x1: Math.min(...this.pathObject.xCords),\n                y1: Math.min(...this.pathObject.yCords),\n                x2: Math.max(...this.pathObject.xCords),\n                y2: Math.max(...this.pathObject.yCords),\n            };\n            //Save\n            this.index = incOrDec(this.index, \"increment\", 1);\n            this.drawingData.push(this.pathObject);\n            //Set new pathObject\n            this.pathObject = {\n                type: \"stroke\",\n                path: new Path2D(),\n                resizedPath: null,\n                lineWidth: this.context.lineWidth,\n                strokeStyle: String(this.context.strokeStyle),\n                operation: \"source-over\",\n                coords: {},\n                resizedCoords: {},\n                xCords: [],\n                yCords: [],\n                resizedXCords: [],\n                resizedYCords: [],\n            };\n        }\n        if (this.actions.resizing) {\n            this.shouldResize = { toggled: false, from: \"\" };\n            this.actions.resizing = false;\n            if (this.selectedDrawingIndex !== null) {\n                const selectedDrawing = this.drawingData[this.selectedDrawingIndex];\n                this.updateToResized(selectedDrawing);\n            }\n        }\n        if (this.actions.lining) {\n            this.shouldLine = false;\n            this.actions.lining = false;\n            //Set end points\n            this.lineObject.coords.endX = this.mouseX;\n            this.lineObject.coords.endY = this.mouseY;\n            //Take the path and line it to end\n            this.lineObject.path.lineTo(this.mouseX, this.mouseY);\n            //Save new line\n            this.index = incOrDec(this.index, \"increment\", 1);\n            this.drawingData.push(this.lineObject);\n            //New lineObject\n            this.lineObject = {\n                type: \"line\",\n                path: new Path2D(),\n                resizedPath: null,\n                lineWidth: 5,\n                strokeStyle: \"black\",\n                operation: \"source-over\",\n                coords: {},\n                resizedCoords: {},\n            };\n        }\n        this.redraw(this.drawingData);\n    };\n    //Handles moving mouse\n    mouseMoveHandler = (e) => {\n        const evtType = e.touches ? e.touches[0] : e;\n        //Current mouse positions\n        const mouseX = evtType.clientX - this.canvas.offsetLeft;\n        const mouseY = evtType.clientY - this.canvas.offsetTop;\n        //Store current mousePosition\n        this.mouseX = mouseX;\n        this.mouseY = mouseY;\n        this.mouseIsDown ? (this.isDragging = true) : (this.isDragging = false);\n        // If move and resize tool is active\n        if (this.activeTools.moveAndResize) {\n            this.canvas.style.cursor = \"default\";\n            this.drawingData.forEach((drawing, i) => {\n                switch (drawing.type) {\n                    case \"stroke\":\n                        {\n                            if (this.context.isPointInStroke(drawing.path, mouseX, mouseY)) {\n                                this.canvas.style.cursor = \"move\";\n                            }\n                            //IF we are hovering the selected drawing\n                            if (this.selectedDrawingIndex === i &&\n                                this.mouseWithinSelection(mouseX, mouseY, drawing)) {\n                                //Get position within selection\n                                const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, drawing);\n                                //Style accordingly\n                                selectionPosition === \"middle\"\n                                    ? (this.canvas.style.cursor = \"move\")\n                                    : selectionPosition === \"top-left\" || selectionPosition === \"bottom-right\"\n                                        ? (this.canvas.style.cursor = \"nwse-resize\")\n                                        : (this.canvas.style.cursor = \"nesw-resize\");\n                            }\n                        }\n                        break;\n                    case \"text\":\n                        {\n                            if (this.mouseWithinSelection(mouseX, mouseY, drawing)) {\n                                const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, drawing);\n                                selectionPosition === \"middle\"\n                                    ? (this.canvas.style.cursor = \"move\")\n                                    : selectionPosition === \"top-left\" || selectionPosition === \"bottom-right\"\n                                        ? (this.canvas.style.cursor = \"nwse-resize\")\n                                        : (this.canvas.style.cursor = \"nesw-resize\");\n                            }\n                        }\n                        break;\n                    case \"line\":\n                        {\n                            if (this.mouseWithinSelection(mouseX, mouseY, drawing)) {\n                                const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, drawing);\n                                selectionPosition === \"middle\"\n                                    ? (this.canvas.style.cursor = \"move\")\n                                    : (this.canvas.style.cursor = \"pointer\");\n                            }\n                        }\n                        break;\n                }\n            });\n        }\n        //IF we have a selected drawing and we are dragging\n        if (this.selectedDrawingIndex !== null && this.isDragging) {\n            //Move with respect to current mouse\n            const dx = mouseX - this.startX;\n            const dy = mouseY - this.startY;\n            //Selected drawing\n            const selectedDrawing = this.drawingData[this.selectedDrawingIndex];\n            //Coords are required IF not present then throw an error\n            assertRequired(selectedDrawing.coords);\n            switch (selectedDrawing.type) {\n                case \"stroke\":\n                    {\n                        if (this.shouldMove) {\n                            this.actions.moving = true;\n                            //Update x and y coordinates\n                            for (let i = 0; i < selectedDrawing.xCords.length; i++) {\n                                selectedDrawing.xCords[i] += dx;\n                                selectedDrawing.yCords[i] += dy;\n                            }\n                            //Update left, top, right and bottom\n                            selectedDrawing.coords.x1 = Math.min(...selectedDrawing.xCords);\n                            selectedDrawing.coords.y1 = Math.min(...selectedDrawing.yCords);\n                            selectedDrawing.coords.x2 = Math.max(...selectedDrawing.xCords);\n                            selectedDrawing.coords.y2 = Math.max(...selectedDrawing.yCords);\n                            //Create new path from existing path\n                            const newPath = new Path2D();\n                            const m = new DOMMatrix().translate(dx, dy);\n                            newPath.addPath(selectedDrawing.path, m);\n                            selectedDrawing.path = newPath;\n                            //Set start positions to current\n                            this.startX = mouseX;\n                            this.startY = mouseY;\n                        }\n                        else {\n                            const from = this.shouldResize.from;\n                            this.actions.resizing = true;\n                            const { scaleOriginXPos, scaleOriginYPos, scale } = this.getScaleInfo(from, selectedDrawing, mouseX, mouseY);\n                            const scaleOriginX = scaleOriginXPos;\n                            const scaleOriginY = scaleOriginYPos;\n                            const scaleFactor = scale;\n                            const resizedPath = new Path2D();\n                            //Create copy\n                            const resizedXCords = [...selectedDrawing.xCords];\n                            const resizedYCords = [...selectedDrawing.yCords];\n                            const originalDistanceX = [];\n                            const originalDistanceY = [];\n                            //Calculate original distance between origin and x,y coordinates\n                            for (let i = 0; i < selectedDrawing.xCords.length; i++) {\n                                originalDistanceX[i] = scaleOriginX - selectedDrawing.xCords[i];\n                                originalDistanceY[i] = scaleOriginY - selectedDrawing.yCords[i];\n                            }\n                            //Update to resized coords\n                            for (let i = 0; i < resizedXCords.length; i++) {\n                                //Calculate new distance based on scale factor\n                                const newDistanceX = originalDistanceX[i] * scaleFactor;\n                                const newDistanceY = originalDistanceY[i] * scaleFactor;\n                                //Place resized coords in the correct place\n                                resizedXCords[i] = scaleOriginX - newDistanceX;\n                                resizedYCords[i] = scaleOriginY - newDistanceY;\n                                //Move path to new coords\n                                resizedPath.moveTo(resizedXCords[i - 1], resizedYCords[i - 1]);\n                                //Create line to new coords\n                                resizedPath.lineTo(resizedXCords[i], resizedYCords[i]);\n                            }\n                            //Set resized left, right, top and bottom\n                            selectedDrawing.resizedCoords.resizedX1 = Math.min(...resizedXCords);\n                            selectedDrawing.resizedCoords.resizedY1 = Math.min(...resizedYCords);\n                            selectedDrawing.resizedCoords.resizedX2 = Math.max(...resizedXCords);\n                            selectedDrawing.resizedCoords.resizedY2 = Math.max(...resizedYCords);\n                            selectedDrawing.resizedXCords = resizedXCords;\n                            selectedDrawing.resizedYCords = resizedYCords;\n                            selectedDrawing.resizedPath = resizedPath;\n                        }\n                    }\n                    break;\n                case \"text\":\n                    {\n                        if (this.shouldMove) {\n                            this.actions.moving = true;\n                            //Assign new coordinates\n                            selectedDrawing.coords.x1 += dx;\n                            selectedDrawing.coords.y1 += dy;\n                            selectedDrawing.coords.x2 += dx;\n                            selectedDrawing.coords.y2 += dy;\n                            this.startX = mouseX;\n                            this.startY = mouseY;\n                        }\n                        else {\n                            const from = this.shouldResize.from;\n                            this.actions.resizing = true;\n                            const { scaleOriginXPos, scaleOriginYPos, startCornerXPos, startCornerYPos, scale } = this.getScaleInfo(from, selectedDrawing, mouseX, mouseY);\n                            const startCornerX = startCornerXPos;\n                            const startCornerY = startCornerYPos;\n                            const scaleOriginX = scaleOriginXPos;\n                            const scaleOriginY = scaleOriginYPos;\n                            //Scale factor based on mouse\n                            const scaleFactor = scale;\n                            //Create copy of original font string\n                            const fontStringCopy = selectedDrawing.font.slice();\n                            //Convert font size to number/float\n                            const fontSize = parseFloat(fontStringCopy);\n                            //Get original distance from scale origin to start corner/current mouse\n                            const originalDistanceX = scaleOriginX - startCornerX;\n                            const originalDistanceY = scaleOriginY - startCornerY;\n                            //Resize font size\n                            const resizedFontSize = fontSize * scaleFactor;\n                            //Get new distance based on scale factor\n                            const newDistanceX = originalDistanceX * scaleFactor;\n                            const newDistanceY = originalDistanceY * scaleFactor;\n                            //Replace original font size with resized\n                            const newFont = fontStringCopy.replace(fontSize.toString(), resizedFontSize.toString());\n                            //Store new left and right\n                            if (from === \"top-left\" || from === \"bottom-left\") {\n                                selectedDrawing.resizedCoords.resizedX1 = scaleOriginX - newDistanceX;\n                                selectedDrawing.resizedCoords.resizedX2 = scaleOriginX;\n                            }\n                            else {\n                                selectedDrawing.resizedCoords.resizedX1 = scaleOriginX;\n                                selectedDrawing.resizedCoords.resizedX2 = scaleOriginX - newDistanceX;\n                            }\n                            //Store new top and bottom\n                            if (from === \"top-left\" || from === \"top-right\") {\n                                selectedDrawing.resizedCoords.resizedY1 = scaleOriginY - newDistanceY;\n                                selectedDrawing.resizedCoords.resizedY2 = scaleOriginY;\n                            }\n                            else {\n                                selectedDrawing.resizedCoords.resizedY1 = scaleOriginY;\n                                selectedDrawing.resizedCoords.resizedY2 = scaleOriginY - newDistanceY;\n                            }\n                            //Store the new font size\n                            selectedDrawing.resizedFont = newFont;\n                        }\n                    }\n                    break;\n                case \"line\":\n                    {\n                        if (this.shouldMove) {\n                            this.actions.moving = true;\n                            //Assign new start and end coordinates\n                            selectedDrawing.coords.startX += dx;\n                            selectedDrawing.coords.startY += dy;\n                            selectedDrawing.coords.endX += dx;\n                            selectedDrawing.coords.endY += dy;\n                            //Create new path from existing path\n                            const newPath = new Path2D();\n                            const m = new DOMMatrix().translate(dx, dy);\n                            newPath.addPath(selectedDrawing.path, m);\n                            selectedDrawing.path = newPath;\n                            this.startX = mouseX;\n                            this.startY = mouseY;\n                        }\n                        else {\n                            const from = this.shouldResize.from;\n                            this.actions.resizing = true;\n                            const { scaleOriginXPos, scaleOriginYPos, startCornerXPos, startCornerYPos } = this.getScaleInfo(from, selectedDrawing, mouseX, mouseY);\n                            const resizedPath = new Path2D();\n                            const startCornerX = startCornerXPos;\n                            const startCornerY = startCornerYPos;\n                            const scaleOriginX = scaleOriginXPos;\n                            const scaleOriginY = scaleOriginYPos;\n                            //Assign start and end x\n                            if (startCornerX === selectedDrawing.coords.startX) {\n                                selectedDrawing.resizedCoords.resizedStartX = mouseX;\n                                selectedDrawing.resizedCoords.resizedEndX = scaleOriginX;\n                            }\n                            else {\n                                selectedDrawing.resizedCoords.resizedStartX = scaleOriginX;\n                                selectedDrawing.resizedCoords.resizedEndX = mouseX;\n                            }\n                            //Assign start and end y\n                            if (startCornerY === selectedDrawing.coords.startY) {\n                                selectedDrawing.resizedCoords.resizedStartY = mouseY;\n                                selectedDrawing.resizedCoords.resizedEndY = scaleOriginY;\n                            }\n                            else {\n                                selectedDrawing.resizedCoords.resizedStartY = scaleOriginY;\n                                selectedDrawing.resizedCoords.resizedEndY = mouseY;\n                            }\n                            this.context.beginPath();\n                            resizedPath.moveTo(mouseX, mouseY);\n                            resizedPath.lineTo(scaleOriginX, scaleOriginY);\n                            selectedDrawing.resizedPath = resizedPath;\n                        }\n                    }\n                    break;\n            }\n            this.redraw(this.drawingData);\n        }\n        if ((this.shouldDraw && this.isDragging) || (this.shouldErase && this.isDragging)) {\n            this.shouldDraw ? (this.actions.drawing = true) : (this.actions.drawing = false);\n            this.shouldErase ? (this.actions.erasing = true) : (this.actions.erasing = false);\n            this.redraw(this.drawingData);\n            //Set props for current path object\n            this.setCtxStyles(this.pathObject);\n            this.addCoords(mouseX, mouseY, true);\n            this.pathObject.path.lineTo(mouseX, mouseY);\n            this.context.stroke(this.pathObject.path);\n        }\n        if (this.shouldLine) {\n            this.actions.lining = true;\n            //Redraw data\n            this.redraw(this.drawingData);\n            this.setCtxStyles(this.lineObject);\n            //Begin current path\n            this.context.beginPath();\n            //Move context to start position of lineObject\n            this.context.moveTo(this.lineObject.coords.startX, this.lineObject.coords.startY); //We know that since we \"shouldLine\" we have clicked so we can say as\n            //Draw a line to current mouse position\n            this.context.lineTo(mouseX, mouseY);\n            //Close the path and save -> repeat while moving\n            this.context.closePath();\n            this.context.stroke();\n        }\n        e.preventDefault();\n    };\n    //Function that updates given drawings coords to resized coords\n    updateToResized(drawing) {\n        if (drawing.type === \"stroke\") {\n            drawing.xCords = drawing.resizedXCords;\n            drawing.yCords = drawing.resizedYCords;\n            drawing.coords.x1 = Math.min(...drawing.xCords);\n            drawing.coords.y1 = Math.min(...drawing.yCords);\n            drawing.coords.x2 = Math.max(...drawing.xCords);\n            drawing.coords.y2 = Math.max(...drawing.yCords);\n            drawing.path = drawing.resizedPath;\n        }\n        else if (drawing.type === \"text\") {\n            drawing.coords.x1 = drawing.resizedCoords.resizedX1;\n            drawing.coords.y1 = drawing.resizedCoords.resizedY1;\n            drawing.coords.x2 = drawing.resizedCoords.resizedX2;\n            drawing.coords.y2 = drawing.resizedCoords.resizedY2;\n            drawing.font = drawing.resizedFont;\n        }\n        else {\n            drawing.coords.startX = drawing.resizedCoords.resizedStartX;\n            drawing.coords.endX = drawing.resizedCoords.resizedEndX;\n            drawing.coords.startY = drawing.resizedCoords.resizedStartY;\n            drawing.coords.endY = drawing.resizedCoords.resizedEndY;\n            drawing.path = drawing.resizedPath;\n        }\n    }\n    //Adds each coordinate to array\n    addCoords(x, y, dragging) {\n        this.pathObject.xCords.push(x);\n        this.pathObject.yCords.push(y);\n        this.isDragging = dragging;\n    }\n    //Function that returns correct coordinates and scalefactor for scaling\n    getScaleInfo(from, element, currentMouseX, currentMouseY) {\n        assertRequired(element.coords);\n        if (element.type === \"line\") {\n            const startCornerX = from === \"start\" ? element.coords.startX : element.coords.endX;\n            const startCornerY = from === \"start\" ? element.coords.startY : element.coords.endY;\n            const scaleOriginX = from === \"start\" ? element.coords.endX : element.coords.startX;\n            const scaleOriginY = from === \"start\" ? element.coords.endY : element.coords.startY;\n            return {\n                scaleOriginXPos: scaleOriginX,\n                scaleOriginYPos: scaleOriginY,\n                startCornerXPos: startCornerX,\n                startCornerYPos: startCornerY,\n                scale: 0,\n            };\n        }\n        else {\n            //IF scaling from the left side then start = left : start = right;\n            const startCornerX = from.includes(\"left\") ? element.coords.x1 : element.coords.x2;\n            const startCornerY = from.includes(\"top\") ? element.coords.y1 : element.coords.y2;\n            //IF scaling from left side then origin is opposite side so that we scale inwards or outwards based on corner\n            const scaleOriginX = from.includes(\"left\") ? element.coords.x2 : element.coords.x1;\n            const scaleOriginY = from.includes(\"top\") ? element.coords.y2 : element.coords.y1;\n            //For the scaling to work properly i also need where we scale from\n            //Since scaling from left side to right side would not work with e.g (x1 - x2 so instead x2 - x1 for distance)\n            const originalDistance = from.includes(\"left\")\n                ? scaleOriginX - startCornerX\n                : startCornerX -\n                    scaleOriginX +\n                    (from.includes(\"top\") ? scaleOriginY - startCornerY : startCornerY - scaleOriginY);\n            const currentDistance = from.includes(\"left\")\n                ? scaleOriginX - currentMouseX\n                : currentMouseX -\n                    scaleOriginX +\n                    (from.includes(\"top\") ? scaleOriginY - currentMouseY : currentMouseY - scaleOriginY);\n            const scaleFactor = currentDistance / originalDistance;\n            return {\n                scaleOriginXPos: scaleOriginX,\n                scaleOriginYPos: scaleOriginY,\n                startCornerXPos: startCornerX,\n                startCornerYPos: startCornerY,\n                scale: scaleFactor,\n            };\n        }\n    }\n    //Checks if mouse is within selection rectangle for those that have it\n    mouseWithinSelection(x, y, drawing) {\n        assertRequired(drawing.coords);\n        let mouseIsIn;\n        //Fine if its close enough\n        const offset = 10;\n        if (drawing.type === \"line\") {\n            const { startX, endX, startY, endY } = drawing.coords;\n            const startX1 = startX - offset;\n            const startX2 = startX + offset;\n            const startY1 = startY - offset;\n            const startY2 = startY + offset;\n            const endX1 = endX - offset;\n            const endX2 = endX + offset;\n            const endY1 = endY - offset;\n            const endY2 = endY + offset;\n            mouseIsIn = this.mouseWithin(startX1, startX2, startY1, startY2, x, y)\n                ? \"start\"\n                : this.mouseWithin(endX1, endX2, endY1, endY2, x, y)\n                    ? \"end\"\n                    : this.context.isPointInStroke(drawing.path, x, y)\n                        ? \"middle\"\n                        : \"\";\n        }\n        else {\n            const { x1, y1, x2, y2 } = drawing.coords;\n            //Top left rectangle\n            const topLeftX1 = x1 - offset;\n            const topLeftX2 = x1 + offset;\n            const topLeftY1 = y1 - offset;\n            const topLeftY2 = y1 + offset;\n            //Top right rectangle\n            const topRightX1 = x2 - offset;\n            const topRightX2 = x2 + offset;\n            const topRightY1 = y1 - offset;\n            const topRightY2 = y1 + offset;\n            //Bottom right rectangle\n            const bottomRightX1 = x2 - offset;\n            const bottomRightX2 = x2 + offset;\n            const bottomRightY1 = y2 - offset;\n            const bottomRightY2 = y2 + offset;\n            //Bottom left rectangle\n            const bottomLeftX1 = x1 - offset;\n            const bottomLeftX2 = x1 + offset;\n            const bottomLeftY1 = y2 - offset;\n            const bottomLeftY2 = y2 + offset;\n            mouseIsIn = this.mouseWithin(topLeftX1, topLeftX2, topLeftY1, topLeftY2, x, y)\n                ? \"top-left\"\n                : this.mouseWithin(topRightX1, topRightX2, topRightY1, topRightY2, x, y)\n                    ? \"top-right\"\n                    : this.mouseWithin(bottomRightX1, bottomRightX2, bottomRightY1, bottomRightY2, x, y)\n                        ? \"bottom-right\"\n                        : this.mouseWithin(bottomLeftX1, bottomLeftX2, bottomLeftY1, bottomLeftY2, x, y)\n                            ? \"bottom-left\"\n                            : this.mouseWithin(x1, x2, y1, y2, x, y)\n                                ? \"middle\"\n                                : \"\";\n        }\n        return mouseIsIn;\n    }\n    //Function for well.. creating a drawing selection\n    createDrawingSelection(drawing) {\n        this.context.globalCompositeOperation = \"source-over\";\n        this.context.strokeStyle = \"#738FE5\";\n        this.context.lineWidth = 1;\n        if (drawing.type === \"stroke\" || drawing.type === \"text\") {\n            const coords = getCorrectCoords(drawing, this.actions.resizing);\n            const width = coords.x2 - coords.x1;\n            const height = coords.y2 - coords.y1;\n            //Draw main rectangle\n            this.context.strokeRect(coords.x1, coords.y1, width, height);\n            //Draw corners\n            this.drawCornerPoints(drawing);\n        }\n        else {\n            const coords = getCorrectCoords(drawing, this.actions.resizing);\n            //Draw line from start to end\n            this.context.lineWidth = 1;\n            this.context.moveTo(coords.startX, coords.startY);\n            this.context.lineTo(coords.endX, coords.endY);\n            this.context.stroke();\n            this.drawCornerPoints(drawing);\n        }\n    }\n    //Function for drawing corner points :P\n    drawCornerPoints(drawing) {\n        this.context.lineWidth = 5;\n        let x;\n        let y;\n        if (drawing.type === \"stroke\" || drawing.type === \"text\") {\n            const coords = getCorrectCoords(drawing, this.actions.resizing);\n            //Selection has 4 corners\n            for (let i = 0; i < 4; i++) {\n                i === 0\n                    ? ((x = coords.x1), (y = coords.y1)) //First draw top left corner\n                    : i === 1\n                        ? ((x = coords.x2), (y = coords.y1)) //Second draw top right corner\n                        : i === 2\n                            ? ((x = coords.x1), (y = coords.y2)) //Third draw bottom left corner\n                            : ((x = coords.x2), (y = coords.y2)); //Last draw bottom right corner\n                this.context.beginPath();\n                this.context.arc(x, y, 1, 0, 2 * Math.PI);\n                this.context.stroke();\n            }\n        }\n        else {\n            const coords = getCorrectCoords(drawing, this.actions.resizing);\n            //Selection has 2 ends\n            for (let i = 0; i < 2; i++) {\n                i === 0\n                    ? ((x = coords.startX), (y = coords.startY))\n                    : ((x = coords.endX), (y = coords.endY));\n                this.context.beginPath();\n                this.context.arc(x, y, 1, 0, 2 * Math.PI);\n                this.context.stroke();\n            }\n        }\n    }\n    //Checks if mouse is within given coordinates\n    mouseWithin(x1, x2, y1, y2, x, y) {\n        if (x >= x1 && x <= x2 && y >= y1 && y <= y2)\n            return true;\n        return false;\n    }\n    //Function for setting styles based on drawing\n    setCtxStyles(drawing) {\n        this.context.globalCompositeOperation = drawing.operation;\n        this.context.lineCap = \"round\";\n        if (drawing.type === \"stroke\" || drawing.type === \"line\") {\n            this.context.lineWidth = drawing.lineWidth;\n            this.context.strokeStyle = drawing.strokeStyle;\n        }\n        else if (drawing.type === \"text\") {\n            this.context.textBaseline = drawing.baseline;\n            this.context.font = drawing.font;\n        }\n    }\n    //Function for redrawing canvas when interactive\n    redraw(drawingData) {\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (drawingData.length <= 0)\n            return;\n        drawingData.forEach((drawing, i) => {\n            switch (drawing.type) {\n                case \"stroke\":\n                    if (this.selectedDrawingIndex === i) {\n                        if (this.actions.resizing) {\n                            this.setCtxStyles(drawing);\n                            this.context.stroke(drawing.resizedPath);\n                            this.createDrawingSelection(drawing);\n                            return;\n                        }\n                        this.createDrawingSelection(drawing);\n                    }\n                    this.setCtxStyles(drawing);\n                    this.context.stroke(drawing.path);\n                    break;\n                case \"text\":\n                    if (this.selectedDrawingIndex === i) {\n                        if (this.actions.resizing) {\n                            assertRequired(drawing.resizedCoords);\n                            this.setCtxStyles(drawing);\n                            this.context.font = drawing.resizedFont;\n                            this.context.fillText(drawing.text, drawing.resizedCoords.resizedX1, drawing.resizedCoords.resizedY1);\n                            this.createDrawingSelection(drawing);\n                            return;\n                        }\n                        this.createDrawingSelection(drawing);\n                    }\n                    this.setCtxStyles(drawing);\n                    this.context.fillText(drawing.text, drawing.coords.x1, drawing.coords.y1);\n                    break;\n                case \"line\":\n                    if (this.selectedDrawingIndex === i) {\n                        if (this.actions.resizing) {\n                            this.setCtxStyles(drawing);\n                            this.context.stroke(drawing.resizedPath);\n                            this.createDrawingSelection(drawing);\n                            return;\n                        }\n                    }\n                    this.setCtxStyles(drawing);\n                    this.context.stroke(drawing.path);\n                    if (this.selectedDrawingIndex === i) {\n                        this.createDrawingSelection(drawing);\n                    }\n                    break;\n            }\n        });\n    }\n    //Function that checks if given element is target\n    targetIs(element, target) {\n        if ((target.id && target.id === element.id) ||\n            (target.className && target.className === element.className)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n}\nnew DrawingCanvas(\"drawing-board\");\n//# sourceMappingURL=index.js.map","import {\n  excludeNullishProps,\n  assignCorrectly,\n  assertRequired,\n  incOrDec,\n  createPersonalElement,\n} from \"./utils/common.js\";\n\nimport { getCorrectCoords } from \"./utils/overloads.js\";\n\n//Import element types\nimport {\n  OptionElement,\n  DrawingElements,\n  LineElement,\n  PathElement,\n  TextElement,\n} from \"./types/elements.js\";\n\n\nclass DrawingCanvas {\n  private canvas: HTMLCanvasElement;\n  private context: CanvasRenderingContext2D;\n  private controller: HTMLElement | null = document.getElementById(\"toolbar\");\n\n  //Base tools\n  private tools: Tools = {\n    pencil: <HTMLButtonElement | null>document.getElementById(\"pencil\"),\n    eraser: <HTMLButtonElement | null>document.getElementById(\"eraser\"),\n    moveAndResize: <HTMLButtonElement | null>document.getElementById(\"mv-rz\"),\n    text: <HTMLButtonElement | null>document.getElementById(\"text\"),\n    line: <HTMLButtonElement | null>document.getElementById(\"line\"),\n  };\n\n  //Tools for changing state of tools\n  private toolModifiers: ToolModifiers = {\n    color: <HTMLInputElement | null>document.getElementById(\"color\"),\n    width: <HTMLInputElement | null>document.getElementById(\"lineWidth\"),\n  };\n\n  //Tools for changing state of Canvas\n  private canvasModifiers: CanvasModifiers = {\n    clear: <HTMLButtonElement | null>document.getElementById(\"clear\"),\n    undo: <HTMLButtonElement | null>document.getElementById(\"undo\"),\n  };\n\n  //For state tracking\n  private actions: Actions = {\n    drawing: false,\n    erasing: false,\n    moving: false,\n    resizing: false,\n    writing: false,\n    lining: false,\n  };\n\n  private shouldDraw = false;\n  private shouldErase = false;\n  private shouldMove = false;\n  private shouldResize = {\n    toggled: false,\n    from: \"\",\n  };\n  private shouldLine = false;\n\n  private activeTools: ToolStates = {\n    pencil: false,\n    eraser: false,\n    moveAndResize: false,\n    text: false,\n    line: false,\n  };\n\n  private mouseIsDown = false;\n  private isDragging = false;\n\n  private index = -1;\n  private selectedDrawingIndex: number | null = null;\n\n  //Create default path object\n  private pathObject: PathElement = {\n    type: \"stroke\",\n    path: new Path2D(),\n    resizedPath: null,\n    lineWidth: 5,\n    strokeStyle: \"black\",\n    operation: \"source-over\",\n    coords: {},\n    resizedCoords: {},\n    xCords: [],\n    yCords: [],\n    resizedXCords: [],\n    resizedYCords: [],\n  };\n\n  //Create default text object\n  private textObject: TextElement = {\n    type: \"text\",\n    text: \"\",\n    font: \"30pt sans-serif\",\n    resizedFont: \"\",\n    baseline: \"top\",\n    operation: \"source-over\",\n    coords: {},\n    resizedCoords: {},\n  };\n\n  //Create default line object\n  private lineObject: LineElement = {\n    type: \"line\",\n    path: new Path2D(),\n    resizedPath: null,\n    lineWidth: 5,\n    strokeStyle: \"black\",\n    operation: \"source-over\",\n    coords: {},\n    resizedCoords: {},\n  };\n\n  private drawingData: DrawingElements[] = [];\n\n  private startX = 0;\n  private startY = 0;\n  private mouseX = 0;\n  private mouseY = 0;\n\n  private selectedTool: SelectedTool = {};\n\n  constructor(\n    elementId: string,\n\n    options?: {\n      width?: number;\n      height?: number;\n      elements?: OptionElement[];\n    }\n  ) {\n    //Select canvas element\n    const canvas = document.getElementById(elementId) as HTMLCanvasElement;\n    const context = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n\n    options?.elements?.forEach((element) => {\n      //Assign each element passed to options to its correct place\n      assignCorrectly(element, this.tools);\n      assignCorrectly(element, this.toolModifiers);\n      assignCorrectly(element, this.canvasModifiers);\n    });\n\n    //Check if width and height has been set\n    options?.width\n      ? (canvas.width = options.width)\n      : (canvas.width = window.innerWidth - canvas.offsetLeft);\n    options?.height\n      ? (canvas.height = options.height)\n      : (canvas.height = window.innerHeight - canvas.offsetTop);\n\n    //Save canvas and context in class\n    this.canvas = canvas;\n    this.context = context;\n\n    //Assign default values\n    this.canvas.style.cursor = \"crosshair\";\n\n    //Set selected tool as pencil if exists\n    this.tools.pencil &&\n      ((this.selectedTool.element = this.tools.pencil), (this.selectedTool.name = \"pencil\"));\n    this.selectedTool.element?.classList.add(\"active\");\n    this.activeTools[this.selectedTool.name as keyof ToolStates] = true;\n\n    //Add eventlisteners to canvas\n    this.listen();\n  }\n\n  //Listen for events and call correct function\n  private listen() {\n    const canvas = this.canvas;\n    const controller = this.controller;\n\n    canvas.addEventListener(\"mousedown\", this.pressDownHandler);\n    canvas.addEventListener(\"mouseup\", this.mouseUpHandler);\n    canvas.addEventListener(\"mousemove\", this.mouseMoveHandler);\n\n    canvas.addEventListener(\"touchstart\", this.pressDownHandler);\n    canvas.addEventListener(\"touchend\", this.mouseUpHandler);\n    canvas.addEventListener(\"touchmove\", this.mouseMoveHandler);\n\n    controller?.addEventListener(\"change\", this.changeHandler);\n    controller?.addEventListener(\"click\", this.toolSelectHandler);\n  }\n\n  //Controller Change handler\n  private changeHandler = (e: Event) => {\n    const target = e.target as HTMLInputElement;\n\n    const colorPicker = this.toolModifiers.color;\n    const lineWidthPicker = this.toolModifiers.width;\n\n    if (colorPicker && this.targetIs(colorPicker, target)) {\n      //Change current path object strokeStyle\n      this.pathObject.strokeStyle = target.value;\n    }\n\n    if (lineWidthPicker && this.targetIs(lineWidthPicker, target)) {\n      this.pathObject.lineWidth = Number(target.value);\n    }\n  };\n\n  //Controller click handler\n  private toolSelectHandler = (e: Event) => {\n    this.selectedDrawingIndex = null;\n\n    const target = e.target as HTMLElement | HTMLButtonElement | HTMLInputElement;\n    const context = this.context;\n\n    //Filter out nullish value props\n    const definedTools = excludeNullishProps(this.tools);\n    const definedCanvasModifiers = excludeNullishProps(this.canvasModifiers);\n\n    if (Object.keys(definedTools).length > 0) {\n      //Loop each defined element and check which of them are the target\n      Object.entries(definedTools).forEach(([k, v]) => {\n        //IF tool is target\n        if (v === target) {\n          //Store tool name and element as selected\n          this.selectedTool.element = v;\n          this.selectedTool.name = k as keyof ToolStates;\n        } else {\n          this.activeTools[k as keyof ToolStates] = false;\n          v?.classList.remove(\"active\");\n        }\n      });\n\n      //Add active class for the selected tool and update activeTools object\n      this.selectedTool.element?.classList.add(\"active\");\n      this.activeTools[this.selectedTool.name as keyof ToolStates] = true;\n\n      //Set correct cursor based on selectedTool\n      this.selectedTool.name === \"pencil\" ||\n        this.selectedTool.name === \"eraser\" ||\n        this.selectedTool.name === \"line\"\n        ? (this.canvas.style.cursor = \"crosshair\")\n        : this.selectedTool.name === \"text\"\n          ? (this.canvas.style.cursor = \"text\")\n          : (this.canvas.style.cursor = \"default\");\n    }\n\n    if (Object.keys(definedCanvasModifiers).length > 0) {\n      if (definedCanvasModifiers.clear === target) {\n        context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        this.index = -1;\n\n        this.drawingData = [];\n      }\n\n      if (definedCanvasModifiers.undo === target) {\n        if (this.index <= 0) {\n          context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n          this.index = -1;\n          this.drawingData = [];\n        } else {\n          this.index -= 1;\n          this.drawingData.pop();\n\n          this.redraw(this.drawingData);\n        }\n      }\n    }\n  };\n\n  //Handles pressdown/click\n  private pressDownHandler = (e: MouseEvent | TouchEvent) => {\n    this.mouseIsDown = true;\n\n    if (this.actions.writing) return;\n    //Check if event is touch or mouse\n    const evtType = (e as TouchEvent).touches ? (e as TouchEvent).touches[0] : (e as MouseEvent);\n\n    const { pencil, eraser, moveAndResize, text, line } = this.activeTools;\n\n    const mouseY = evtType.clientY - this.canvas.offsetTop;\n    const mouseX = evtType.clientX - this.canvas.offsetLeft;\n\n    //Store starting positions\n    this.startX = mouseX;\n    this.startY = mouseY;\n\n    //IF eraser is the active tool\n    if (eraser) {\n      this.pathObject.operation = \"destination-out\";\n\n      this.shouldErase = true;\n\n      this.addCoords(mouseX, mouseY, false);\n    }\n\n    if (pencil) {\n      this.pathObject.operation = \"source-over\";\n\n      this.shouldDraw = true;\n\n      this.addCoords(mouseX, mouseY, false);\n    }\n\n    if (moveAndResize) {\n      //IF no paths\n      if (this.drawingData.length <= 0) return;\n      //IF there already is a selected drawing\n      if (this.selectedDrawingIndex !== null) {\n        const selected = this.drawingData[this.selectedDrawingIndex];\n\n        //Get position of mouse within drawing\n        const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, selected);\n\n        //IF mouse is not in drawing anymore\n        if (!selectionPosition) {\n          //Disselect the selected\n          this.selectedDrawingIndex = null;\n        } else {\n          //IF mouse is inside the selection THEN check if move or resize\n          selectionPosition === \"middle\"\n            ? (this.shouldMove = true)\n            : ((this.shouldResize.toggled = true),\n              (this.shouldResize.from = selectionPosition as string));\n        }\n      }\n\n      //Loop through each drawing and check if one has been clicked on and set that as the selected drawing\n      this.drawingData.forEach((drawing, i) => {\n        if (drawing.type === \"stroke\" || drawing.type === \"line\") {\n          //Mouse is inside stroke\n          if (this.context.isPointInStroke(drawing.path, mouseX, mouseY)) {\n            //Set selected drawing\n            this.selectedDrawingIndex = i;\n            const selected = this.drawingData[this.selectedDrawingIndex];\n            //Then check mouse position if we should resize or move\n            const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, selected);\n            selectionPosition === \"middle\"\n              ? (this.shouldMove = true)\n              : ((this.shouldResize.toggled = true),\n                (this.shouldResize.from = selectionPosition as string));\n          }\n        } else {\n          if (this.mouseWithinSelection(mouseX, mouseY, drawing)) {\n            this.selectedDrawingIndex = i;\n            const selected = this.drawingData[this.selectedDrawingIndex];\n            const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, selected);\n\n            selectionPosition === \"middle\"\n              ? (this.shouldMove = true)\n              : ((this.shouldResize.toggled = true),\n                (this.shouldResize.from = selectionPosition as string));\n          }\n        }\n      });\n    }\n\n    if (text) {\n      const canvasContainer = <HTMLElement>document.querySelector(\".drawing-board\");\n\n      //Create textinput\n      const textInput = createPersonalElement(\"input\", canvasContainer, {\n        position: \"fixed\",\n        top: `${evtType.clientY}px`,\n        left: `${evtType.clientX}px`,\n        outline: \"none\",\n        background: \"none\",\n        border: \"none\",\n        \"font-size\": \"30pt\",\n        \"font-family\": \"sans-serif\",\n      });\n\n      //We are now writing\n      this.actions.writing = true;\n\n      //Focus input\n      window.setTimeout(() => textInput.focus(), 0);\n\n      //Runs whenever we unfocus input\n      textInput.addEventListener(\"blur\", () => {\n        this.redraw(this.drawingData);\n\n        //Store value of text in drawing for later refernce when drawing it\n        this.textObject.text = textInput.value;\n\n        //Set context props based on current drawing\n        this.setCtxStyles(this.textObject);\n\n        //Measure the drawn text\n        const textWidth = this.context.measureText(textInput.value).width;\n        const textHeight = parseInt(this.context.font);\n\n        //Init coordinates\n        this.textObject.coords = {\n          x1: mouseX,\n          y1: mouseY,\n          x2: Math.round(mouseX + textWidth),\n          y2: Math.round(mouseY + textHeight),\n        };\n\n        //Draw the text\n        this.context.fillText(this.textObject.text, mouseX, mouseY);\n\n        //Save and store index\n        this.index = incOrDec(this.index, \"increment\", 1);\n        this.drawingData.push(this.textObject);\n\n        canvasContainer.removeChild(textInput);\n\n        this.actions.writing = false;\n\n        //Set new text object\n        this.textObject = {\n          type: \"text\",\n          text: \"\",\n          font: \"30pt sans-serif\",\n          resizedFont: \"\",\n          baseline: \"top\",\n          operation: \"source-over\",\n          coords: {},\n          resizedCoords: {},\n        };\n      });\n\n      textInput.addEventListener(\"keypress\", (e: KeyboardEvent) => {\n        if (e.key === \"Enter\") {\n          textInput.blur();\n        }\n      });\n\n      canvasContainer?.appendChild(textInput);\n    }\n\n    if (line) {\n      if (this.actions.lining) return; //So it jumps to mouseup\n\n      this.lineObject.operation = \"source-over\";\n\n      //Signal that we are trying to draw a line\n      this.shouldLine = true;\n\n      this.lineObject.path.moveTo(mouseX, mouseY);\n      //Init start coordinates\n      this.lineObject.coords = { startX: mouseX, startY: mouseY };\n    }\n  };\n\n  //Handles mouse release\n  private mouseUpHandler = () => {\n    //Reset states\n    this.mouseIsDown = false;\n    this.shouldMove = false;\n    this.actions.moving = false;\n\n    if (this.actions.drawing || this.actions.erasing) {\n      this.shouldDraw = false;\n      this.shouldErase = false;\n\n      this.actions.drawing = false;\n      this.actions.erasing = false;\n\n      //IF its just a click and no stroke\n      if (this.pathObject.xCords.length === 1) {\n        this.pathObject = {\n          type: \"stroke\",\n          path: new Path2D(),\n          resizedPath: null,\n          lineWidth: this.context.lineWidth,\n          strokeStyle: String(this.context.strokeStyle),\n          operation: \"source-over\",\n          coords: {},\n          resizedCoords: {},\n          xCords: [],\n          yCords: [],\n          resizedXCords: [],\n          resizedYCords: [],\n        };\n        return;\n      }\n\n      //Init coords\n      this.pathObject.coords = {\n        x1: Math.min(...this.pathObject.xCords),\n        y1: Math.min(...this.pathObject.yCords),\n        x2: Math.max(...this.pathObject.xCords),\n        y2: Math.max(...this.pathObject.yCords),\n      };\n\n      //Save\n      this.index = incOrDec(this.index, \"increment\", 1);\n      this.drawingData.push(this.pathObject);\n\n      //Set new pathObject\n      this.pathObject = {\n        type: \"stroke\",\n        path: new Path2D(),\n        resizedPath: null,\n        lineWidth: this.context.lineWidth,\n        strokeStyle: String(this.context.strokeStyle),\n        operation: \"source-over\",\n        coords: {},\n        resizedCoords: {},\n        xCords: [],\n        yCords: [],\n        resizedXCords: [],\n        resizedYCords: [],\n      };\n    }\n\n    if (this.actions.resizing) {\n      this.shouldResize = { toggled: false, from: \"\" };\n      this.actions.resizing = false;\n\n      if (this.selectedDrawingIndex !== null) {\n        const selectedDrawing = this.drawingData[this.selectedDrawingIndex];\n\n        this.updateToResized(selectedDrawing);\n      }\n    }\n\n    if (this.actions.lining) {\n      this.shouldLine = false;\n      this.actions.lining = false;\n\n      //Set end points\n      this.lineObject.coords.endX = this.mouseX;\n      this.lineObject.coords.endY = this.mouseY;\n\n      //Take the path and line it to end\n      this.lineObject.path.lineTo(this.mouseX, this.mouseY);\n\n      //Save new line\n      this.index = incOrDec(this.index, \"increment\", 1);\n      this.drawingData.push(this.lineObject);\n\n      //New lineObject\n      this.lineObject = {\n        type: \"line\",\n        path: new Path2D(),\n        resizedPath: null,\n        lineWidth: 5,\n        strokeStyle: \"black\",\n        operation: \"source-over\",\n        coords: {},\n        resizedCoords: {},\n      };\n    }\n\n    this.redraw(this.drawingData);\n  };\n\n  //Handles moving mouse\n  private mouseMoveHandler = (e: MouseEvent | TouchEvent) => {\n    const evtType = (e as TouchEvent).touches ? (e as TouchEvent).touches[0] : (e as MouseEvent);\n\n    //Current mouse positions\n    const mouseX = evtType.clientX - this.canvas.offsetLeft;\n    const mouseY = evtType.clientY - this.canvas.offsetTop;\n\n    //Store current mousePosition\n    this.mouseX = mouseX;\n    this.mouseY = mouseY;\n\n    this.mouseIsDown ? (this.isDragging = true) : (this.isDragging = false);\n\n    // If move and resize tool is active\n    if (this.activeTools.moveAndResize) {\n      this.canvas.style.cursor = \"default\";\n\n      this.drawingData.forEach((drawing, i) => {\n        switch (drawing.type) {\n          case \"stroke\":\n            {\n              if (this.context.isPointInStroke(drawing.path, mouseX, mouseY)) {\n                this.canvas.style.cursor = \"move\";\n              }\n\n              //IF we are hovering the selected drawing\n              if (\n                this.selectedDrawingIndex === i &&\n                this.mouseWithinSelection(mouseX, mouseY, drawing)\n              ) {\n                //Get position within selection\n                const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, drawing);\n\n                //Style accordingly\n                selectionPosition === \"middle\"\n                  ? (this.canvas.style.cursor = \"move\")\n                  : selectionPosition === \"top-left\" || selectionPosition === \"bottom-right\"\n                    ? (this.canvas.style.cursor = \"nwse-resize\")\n                    : (this.canvas.style.cursor = \"nesw-resize\");\n              }\n            }\n            break;\n\n          case \"text\":\n            {\n              if (this.mouseWithinSelection(mouseX, mouseY, drawing)) {\n                const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, drawing);\n\n                selectionPosition === \"middle\"\n                  ? (this.canvas.style.cursor = \"move\")\n                  : selectionPosition === \"top-left\" || selectionPosition === \"bottom-right\"\n                    ? (this.canvas.style.cursor = \"nwse-resize\")\n                    : (this.canvas.style.cursor = \"nesw-resize\");\n              }\n            }\n\n            break;\n\n          case \"line\":\n            {\n              if (this.mouseWithinSelection(mouseX, mouseY, drawing)) {\n                const selectionPosition = this.mouseWithinSelection(mouseX, mouseY, drawing);\n                selectionPosition === \"middle\"\n                  ? (this.canvas.style.cursor = \"move\")\n                  : (this.canvas.style.cursor = \"pointer\");\n              }\n            }\n\n            break;\n        }\n      });\n    }\n\n    //IF we have a selected drawing and we are dragging\n    if (this.selectedDrawingIndex !== null && this.isDragging) {\n      //Move with respect to current mouse\n      const dx = mouseX - this.startX;\n      const dy = mouseY - this.startY;\n\n      //Selected drawing\n      const selectedDrawing = this.drawingData[this.selectedDrawingIndex];\n\n      //Coords are required IF not present then throw an error\n      assertRequired(selectedDrawing.coords);\n\n      switch (selectedDrawing.type) {\n        case \"stroke\":\n          {\n            if (this.shouldMove) {\n              this.actions.moving = true;\n              //Update x and y coordinates\n              for (let i = 0; i < selectedDrawing.xCords.length; i++) {\n                selectedDrawing.xCords[i] += dx;\n                selectedDrawing.yCords[i] += dy;\n              }\n\n              //Update left, top, right and bottom\n              selectedDrawing.coords.x1 = Math.min(...selectedDrawing.xCords);\n              selectedDrawing.coords.y1 = Math.min(...selectedDrawing.yCords);\n              selectedDrawing.coords.x2 = Math.max(...selectedDrawing.xCords);\n              selectedDrawing.coords.y2 = Math.max(...selectedDrawing.yCords);\n\n              //Create new path from existing path\n              const newPath = new Path2D();\n              const m = new DOMMatrix().translate(dx, dy);\n              newPath.addPath(selectedDrawing.path, m);\n\n              selectedDrawing.path = newPath;\n              //Set start positions to current\n              this.startX = mouseX;\n              this.startY = mouseY;\n            } else {\n              const from = this.shouldResize.from;\n              this.actions.resizing = true;\n\n              const { scaleOriginXPos, scaleOriginYPos, scale } = this.getScaleInfo(\n                from,\n                selectedDrawing,\n                mouseX,\n                mouseY\n              );\n\n              const scaleOriginX = scaleOriginXPos;\n              const scaleOriginY = scaleOriginYPos;\n\n              const scaleFactor = scale;\n\n              const resizedPath = new Path2D();\n\n              //Create copy\n              const resizedXCords = [...selectedDrawing.xCords];\n              const resizedYCords = [...selectedDrawing.yCords];\n\n              const originalDistanceX = [];\n              const originalDistanceY = [];\n\n              //Calculate original distance between origin and x,y coordinates\n              for (let i = 0; i < selectedDrawing.xCords.length; i++) {\n                originalDistanceX[i] = scaleOriginX - selectedDrawing.xCords[i];\n                originalDistanceY[i] = scaleOriginY - selectedDrawing.yCords[i];\n              }\n\n              //Update to resized coords\n              for (let i = 0; i < resizedXCords.length; i++) {\n                //Calculate new distance based on scale factor\n                const newDistanceX = originalDistanceX[i] * scaleFactor;\n                const newDistanceY = originalDistanceY[i] * scaleFactor;\n\n                //Place resized coords in the correct place\n                resizedXCords[i] = scaleOriginX - newDistanceX;\n                resizedYCords[i] = scaleOriginY - newDistanceY;\n\n                //Move path to new coords\n                resizedPath.moveTo(resizedXCords[i - 1], resizedYCords[i - 1]);\n                //Create line to new coords\n                resizedPath.lineTo(resizedXCords[i], resizedYCords[i]);\n              }\n              //Set resized left, right, top and bottom\n              selectedDrawing.resizedCoords.resizedX1 = Math.min(...resizedXCords);\n              selectedDrawing.resizedCoords.resizedY1 = Math.min(...resizedYCords);\n              selectedDrawing.resizedCoords.resizedX2 = Math.max(...resizedXCords);\n              selectedDrawing.resizedCoords.resizedY2 = Math.max(...resizedYCords);\n\n              selectedDrawing.resizedXCords = resizedXCords;\n              selectedDrawing.resizedYCords = resizedYCords;\n\n              selectedDrawing.resizedPath = resizedPath;\n            }\n          }\n          break;\n        case \"text\":\n          {\n            if (this.shouldMove) {\n              this.actions.moving = true;\n\n              //Assign new coordinates\n              selectedDrawing.coords.x1 += dx;\n              selectedDrawing.coords.y1 += dy;\n              selectedDrawing.coords.x2 += dx;\n              selectedDrawing.coords.y2 += dy;\n\n              this.startX = mouseX;\n              this.startY = mouseY;\n            } else {\n              const from = this.shouldResize.from;\n              this.actions.resizing = true;\n              const { scaleOriginXPos, scaleOriginYPos, startCornerXPos, startCornerYPos, scale } =\n                this.getScaleInfo(from, selectedDrawing, mouseX, mouseY);\n\n              const startCornerX = startCornerXPos;\n              const startCornerY = startCornerYPos;\n\n              const scaleOriginX = scaleOriginXPos;\n              const scaleOriginY = scaleOriginYPos;\n\n              //Scale factor based on mouse\n              const scaleFactor = scale;\n\n              //Create copy of original font string\n              const fontStringCopy = selectedDrawing.font.slice();\n\n              //Convert font size to number/float\n              const fontSize = parseFloat(fontStringCopy);\n\n              //Get original distance from scale origin to start corner/current mouse\n              const originalDistanceX = scaleOriginX - startCornerX;\n              const originalDistanceY = scaleOriginY - startCornerY;\n\n              //Resize font size\n              const resizedFontSize = fontSize * scaleFactor;\n\n              //Get new distance based on scale factor\n              const newDistanceX = originalDistanceX * scaleFactor;\n              const newDistanceY = originalDistanceY * scaleFactor;\n\n              //Replace original font size with resized\n              const newFont = fontStringCopy.replace(\n                fontSize.toString(),\n                resizedFontSize.toString()\n              );\n\n              //Store new left and right\n              if (from === \"top-left\" || from === \"bottom-left\") {\n                selectedDrawing.resizedCoords.resizedX1 = scaleOriginX - newDistanceX;\n                selectedDrawing.resizedCoords.resizedX2 = scaleOriginX;\n              } else {\n                selectedDrawing.resizedCoords.resizedX1 = scaleOriginX;\n                selectedDrawing.resizedCoords.resizedX2 = scaleOriginX - newDistanceX;\n              }\n\n              //Store new top and bottom\n              if (from === \"top-left\" || from === \"top-right\") {\n                selectedDrawing.resizedCoords.resizedY1 = scaleOriginY - newDistanceY;\n                selectedDrawing.resizedCoords.resizedY2 = scaleOriginY;\n              } else {\n                selectedDrawing.resizedCoords.resizedY1 = scaleOriginY;\n                selectedDrawing.resizedCoords.resizedY2 = scaleOriginY - newDistanceY;\n              }\n\n              //Store the new font size\n              selectedDrawing.resizedFont = newFont;\n            }\n          }\n          break;\n        case \"line\":\n          {\n            if (this.shouldMove) {\n              this.actions.moving = true;\n              //Assign new start and end coordinates\n              selectedDrawing.coords.startX += dx;\n              selectedDrawing.coords.startY += dy;\n              selectedDrawing.coords.endX += dx;\n              selectedDrawing.coords.endY += dy;\n\n              //Create new path from existing path\n              const newPath = new Path2D();\n              const m = new DOMMatrix().translate(dx, dy);\n              newPath.addPath(selectedDrawing.path, m);\n\n              selectedDrawing.path = newPath;\n\n              this.startX = mouseX;\n              this.startY = mouseY;\n            } else {\n              const from = this.shouldResize.from;\n\n              this.actions.resizing = true;\n\n              const { scaleOriginXPos, scaleOriginYPos, startCornerXPos, startCornerYPos } =\n                this.getScaleInfo(from, selectedDrawing, mouseX, mouseY);\n\n              const resizedPath = new Path2D();\n\n              const startCornerX = startCornerXPos;\n              const startCornerY = startCornerYPos;\n\n              const scaleOriginX = scaleOriginXPos;\n              const scaleOriginY = scaleOriginYPos;\n\n              //Assign start and end x\n              if (startCornerX === selectedDrawing.coords.startX) {\n                selectedDrawing.resizedCoords.resizedStartX = mouseX;\n                selectedDrawing.resizedCoords.resizedEndX = scaleOriginX;\n              } else {\n                selectedDrawing.resizedCoords.resizedStartX = scaleOriginX;\n                selectedDrawing.resizedCoords.resizedEndX = mouseX;\n              }\n              //Assign start and end y\n              if (startCornerY === selectedDrawing.coords.startY) {\n                selectedDrawing.resizedCoords.resizedStartY = mouseY;\n                selectedDrawing.resizedCoords.resizedEndY = scaleOriginY;\n              } else {\n                selectedDrawing.resizedCoords.resizedStartY = scaleOriginY;\n                selectedDrawing.resizedCoords.resizedEndY = mouseY;\n              }\n\n              this.context.beginPath();\n              resizedPath.moveTo(mouseX, mouseY);\n              resizedPath.lineTo(scaleOriginX, scaleOriginY);\n\n              selectedDrawing.resizedPath = resizedPath;\n            }\n          }\n\n          break;\n      }\n\n      this.redraw(this.drawingData);\n    }\n\n    if ((this.shouldDraw && this.isDragging) || (this.shouldErase && this.isDragging)) {\n      this.shouldDraw ? (this.actions.drawing = true) : (this.actions.drawing = false);\n      this.shouldErase ? (this.actions.erasing = true) : (this.actions.erasing = false);\n      this.redraw(this.drawingData);\n\n      //Set props for current path object\n      this.setCtxStyles(this.pathObject);\n\n      this.addCoords(mouseX, mouseY, true);\n\n      this.pathObject.path.lineTo(mouseX, mouseY);\n      this.context.stroke(this.pathObject.path);\n    }\n\n    if (this.shouldLine) {\n      this.actions.lining = true;\n      //Redraw data\n      this.redraw(this.drawingData);\n\n      this.setCtxStyles(this.lineObject);\n\n      //Begin current path\n      this.context.beginPath();\n      //Move context to start position of lineObject\n      this.context.moveTo(\n        this.lineObject.coords.startX as number,\n        this.lineObject.coords.startY as number\n      ); //We know that since we \"shouldLine\" we have clicked so we can say as\n\n      //Draw a line to current mouse position\n      this.context.lineTo(mouseX, mouseY);\n      //Close the path and save -> repeat while moving\n      this.context.closePath();\n\n      this.context.stroke();\n    }\n\n    e.preventDefault();\n  };\n\n  //Function that updates given drawings coords to resized coords\n  private updateToResized(drawing: DrawingElements) {\n    if (drawing.type === \"stroke\") {\n      drawing.xCords = drawing.resizedXCords;\n      drawing.yCords = drawing.resizedYCords;\n\n      drawing.coords.x1 = Math.min(...drawing.xCords);\n      drawing.coords.y1 = Math.min(...drawing.yCords);\n      drawing.coords.x2 = Math.max(...drawing.xCords);\n      drawing.coords.y2 = Math.max(...drawing.yCords);\n\n      drawing.path = drawing.resizedPath as Path2D;\n    } else if (drawing.type === \"text\") {\n      drawing.coords.x1 = drawing.resizedCoords.resizedX1;\n      drawing.coords.y1 = drawing.resizedCoords.resizedY1;\n      drawing.coords.x2 = drawing.resizedCoords.resizedX2;\n      drawing.coords.y2 = drawing.resizedCoords.resizedY2;\n\n      drawing.font = drawing.resizedFont;\n    } else {\n      drawing.coords.startX = drawing.resizedCoords.resizedStartX;\n      drawing.coords.endX = drawing.resizedCoords.resizedEndX;\n      drawing.coords.startY = drawing.resizedCoords.resizedStartY;\n      drawing.coords.endY = drawing.resizedCoords.resizedEndY;\n\n      drawing.path = drawing.resizedPath as Path2D;\n    }\n  }\n\n  //Adds each coordinate to array\n  private addCoords(x: number, y: number, dragging: boolean) {\n    this.pathObject.xCords.push(x);\n    this.pathObject.yCords.push(y);\n    this.isDragging = dragging;\n  }\n\n  //Function that returns correct coordinates and scalefactor for scaling\n  private getScaleInfo(\n    from: string,\n    element: DrawingElements,\n    currentMouseX: number,\n    currentMouseY: number\n  ) {\n    assertRequired(element.coords);\n\n    if (element.type === \"line\") {\n      const startCornerX = from === \"start\" ? element.coords.startX : element.coords.endX;\n      const startCornerY = from === \"start\" ? element.coords.startY : element.coords.endY;\n\n      const scaleOriginX = from === \"start\" ? element.coords.endX : element.coords.startX;\n      const scaleOriginY = from === \"start\" ? element.coords.endY : element.coords.startY;\n      return {\n        scaleOriginXPos: scaleOriginX,\n        scaleOriginYPos: scaleOriginY,\n        startCornerXPos: startCornerX,\n        startCornerYPos: startCornerY,\n        scale: 0,\n      };\n    } else {\n      //IF scaling from the left side then start = left : start = right;\n      const startCornerX = from.includes(\"left\") ? element.coords.x1 : element.coords.x2;\n      const startCornerY = from.includes(\"top\") ? element.coords.y1 : element.coords.y2;\n\n      //IF scaling from left side then origin is opposite side so that we scale inwards or outwards based on corner\n      const scaleOriginX = from.includes(\"left\") ? element.coords.x2 : element.coords.x1;\n      const scaleOriginY = from.includes(\"top\") ? element.coords.y2 : element.coords.y1;\n\n      //For the scaling to work properly i also need where we scale from\n      //Since scaling from left side to right side would not work with e.g (x1 - x2 so instead x2 - x1 for distance)\n      const originalDistance = from.includes(\"left\")\n        ? scaleOriginX - startCornerX\n        : startCornerX -\n        scaleOriginX +\n        (from.includes(\"top\") ? scaleOriginY - startCornerY : startCornerY - scaleOriginY);\n\n      const currentDistance = from.includes(\"left\")\n        ? scaleOriginX - currentMouseX\n        : currentMouseX -\n        scaleOriginX +\n        (from.includes(\"top\") ? scaleOriginY - currentMouseY : currentMouseY - scaleOriginY);\n\n      const scaleFactor = currentDistance / originalDistance;\n\n      return {\n        scaleOriginXPos: scaleOriginX,\n        scaleOriginYPos: scaleOriginY,\n        startCornerXPos: startCornerX,\n        startCornerYPos: startCornerY,\n        scale: scaleFactor,\n      };\n    }\n  }\n\n  //Checks if mouse is within selection rectangle for those that have it\n  private mouseWithinSelection(x: number, y: number, drawing: DrawingElements): string {\n    assertRequired(drawing.coords);\n\n    let mouseIsIn: string;\n\n    //Fine if its close enough\n    const offset = 10;\n\n    if (drawing.type === \"line\") {\n      const { startX, endX, startY, endY } = drawing.coords;\n\n      const startX1 = startX - offset;\n      const startX2 = startX + offset;\n      const startY1 = startY - offset;\n      const startY2 = startY + offset;\n\n      const endX1 = endX - offset;\n      const endX2 = endX + offset;\n      const endY1 = endY - offset;\n      const endY2 = endY + offset;\n\n      mouseIsIn = this.mouseWithin(startX1, startX2, startY1, startY2, x, y)\n        ? \"start\"\n        : this.mouseWithin(endX1, endX2, endY1, endY2, x, y)\n          ? \"end\"\n          : this.context.isPointInStroke(drawing.path, x, y)\n            ? \"middle\"\n            : \"\";\n    } else {\n      const { x1, y1, x2, y2 } = drawing.coords;\n\n      //Top left rectangle\n      const topLeftX1 = x1 - offset;\n      const topLeftX2 = x1 + offset;\n      const topLeftY1 = y1 - offset;\n      const topLeftY2 = y1 + offset;\n      //Top right rectangle\n      const topRightX1 = x2 - offset;\n      const topRightX2 = x2 + offset;\n      const topRightY1 = y1 - offset;\n      const topRightY2 = y1 + offset;\n      //Bottom right rectangle\n      const bottomRightX1 = x2 - offset;\n      const bottomRightX2 = x2 + offset;\n      const bottomRightY1 = y2 - offset;\n      const bottomRightY2 = y2 + offset;\n      //Bottom left rectangle\n      const bottomLeftX1 = x1 - offset;\n      const bottomLeftX2 = x1 + offset;\n      const bottomLeftY1 = y2 - offset;\n      const bottomLeftY2 = y2 + offset;\n\n      mouseIsIn = this.mouseWithin(topLeftX1, topLeftX2, topLeftY1, topLeftY2, x, y)\n        ? \"top-left\"\n        : this.mouseWithin(topRightX1, topRightX2, topRightY1, topRightY2, x, y)\n          ? \"top-right\"\n          : this.mouseWithin(bottomRightX1, bottomRightX2, bottomRightY1, bottomRightY2, x, y)\n            ? \"bottom-right\"\n            : this.mouseWithin(bottomLeftX1, bottomLeftX2, bottomLeftY1, bottomLeftY2, x, y)\n              ? \"bottom-left\"\n              : this.mouseWithin(x1, x2, y1, y2, x, y)\n                ? \"middle\"\n                : \"\";\n    }\n\n    return mouseIsIn;\n  }\n\n  //Function for well.. creating a drawing selection\n  private createDrawingSelection(drawing: DrawingElements) {\n    this.context.globalCompositeOperation = \"source-over\";\n    this.context.strokeStyle = \"#738FE5\";\n\n    this.context.lineWidth = 1;\n\n    if (drawing.type === \"stroke\" || drawing.type === \"text\") {\n      const coords = getCorrectCoords(drawing, this.actions.resizing);\n      const width = coords.x2 - coords.x1;\n      const height = coords.y2 - coords.y1;\n\n      //Draw main rectangle\n      this.context.strokeRect(coords.x1, coords.y1, width, height);\n\n      //Draw corners\n      this.drawCornerPoints(drawing);\n    } else {\n      const coords = getCorrectCoords(drawing, this.actions.resizing);\n      //Draw line from start to end\n      this.context.lineWidth = 1;\n      this.context.moveTo(coords.startX, coords.startY);\n      this.context.lineTo(coords.endX, coords.endY);\n      this.context.stroke();\n\n      this.drawCornerPoints(drawing);\n    }\n  }\n\n  //Function for drawing corner points :P\n  private drawCornerPoints(drawing: DrawingElements) {\n    this.context.lineWidth = 5;\n    let x: number;\n    let y: number;\n\n    if (drawing.type === \"stroke\" || drawing.type === \"text\") {\n      const coords = getCorrectCoords(drawing, this.actions.resizing);\n\n      //Selection has 4 corners\n      for (let i = 0; i < 4; i++) {\n        i === 0\n          ? ((x = coords.x1), (y = coords.y1)) //First draw top left corner\n          : i === 1\n            ? ((x = coords.x2), (y = coords.y1)) //Second draw top right corner\n            : i === 2\n              ? ((x = coords.x1), (y = coords.y2)) //Third draw bottom left corner\n              : ((x = coords.x2), (y = coords.y2)); //Last draw bottom right corner\n\n        this.context.beginPath();\n        this.context.arc(x, y, 1, 0, 2 * Math.PI);\n        this.context.stroke();\n      }\n    } else {\n      const coords = getCorrectCoords(drawing, this.actions.resizing);\n\n      //Selection has 2 ends\n      for (let i = 0; i < 2; i++) {\n        i === 0\n          ? ((x = coords.startX), (y = coords.startY))\n          : ((x = coords.endX), (y = coords.endY));\n\n        this.context.beginPath();\n        this.context.arc(x, y, 1, 0, 2 * Math.PI);\n        this.context.stroke();\n      }\n    }\n  }\n\n  //Checks if mouse is within given coordinates\n  private mouseWithin(x1: number, x2: number, y1: number, y2: number, x: number, y: number) {\n    if (x >= x1 && x <= x2 && y >= y1 && y <= y2) return true;\n\n    return false;\n  }\n\n  //Function for setting styles based on drawing\n  private setCtxStyles(drawing: DrawingElements) {\n    this.context.globalCompositeOperation = drawing.operation;\n    this.context.lineCap = \"round\";\n\n    if (drawing.type === \"stroke\" || drawing.type === \"line\") {\n      this.context.lineWidth = drawing.lineWidth;\n      this.context.strokeStyle = drawing.strokeStyle;\n    } else if (drawing.type === \"text\") {\n      this.context.textBaseline = drawing.baseline as CanvasTextBaseline;\n      this.context.font = drawing.font;\n    }\n  }\n\n  //Function for redrawing canvas when interactive\n  private redraw(drawingData: DrawingElements[]) {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    if (drawingData.length <= 0) return;\n\n    drawingData.forEach((drawing, i) => {\n      switch (drawing.type) {\n        case \"stroke\":\n          if (this.selectedDrawingIndex === i) {\n            if (this.actions.resizing) {\n              this.setCtxStyles(drawing);\n\n              this.context.stroke(drawing.resizedPath as Path2D);\n\n              this.createDrawingSelection(drawing);\n\n              return;\n            }\n            this.createDrawingSelection(drawing);\n          }\n\n          this.setCtxStyles(drawing);\n\n          this.context.stroke(drawing.path);\n          break;\n        case \"text\":\n          if (this.selectedDrawingIndex === i) {\n            if (this.actions.resizing) {\n              assertRequired(drawing.resizedCoords);\n              this.setCtxStyles(drawing);\n\n              this.context.font = drawing.resizedFont;\n              this.context.fillText(\n                drawing.text,\n                drawing.resizedCoords.resizedX1,\n                drawing.resizedCoords.resizedY1\n              );\n              this.createDrawingSelection(drawing);\n\n              return;\n            }\n\n            this.createDrawingSelection(drawing);\n          }\n\n          this.setCtxStyles(drawing);\n\n          this.context.fillText(\n            drawing.text,\n            drawing.coords.x1 as number,\n            drawing.coords.y1 as number\n          );\n          break;\n        case \"line\":\n          if (this.selectedDrawingIndex === i) {\n            if (this.actions.resizing) {\n              this.setCtxStyles(drawing);\n              this.context.stroke(drawing.resizedPath as Path2D);\n              this.createDrawingSelection(drawing);\n              return;\n            }\n          }\n\n          this.setCtxStyles(drawing);\n\n          this.context.stroke(drawing.path);\n          if (this.selectedDrawingIndex === i) {\n            this.createDrawingSelection(drawing);\n          }\n          break;\n      }\n    });\n  }\n\n  //Function that checks if given element is target\n  private targetIs(\n    element: HTMLButtonElement | HTMLInputElement | HTMLElement,\n    target: HTMLButtonElement | HTMLInputElement | HTMLElement\n  ) {\n    if (\n      (target.id && target.id === element.id) ||\n      (target.className && target.className === element.className)\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\nnew DrawingCanvas(\"drawing-board\");\n","//Removes nullish values from provided object\nexport const excludeNullishProps = (obj) => {\n    return Object.fromEntries(Object.entries(obj).filter(([, v]) => typeof v !== \"undefined\" && v !== null));\n};\n//Assigns element passed to options to correct property\nexport const assignCorrectly = (element, prop) => {\n    Object.keys(prop).map((key) => {\n        if (element.type === key) {\n            const index = key;\n            if (!element.className && !element.id)\n                throw new Error(`Please provide a class or id for element: ${element.type}`);\n            if (element.className) {\n                const el = document.querySelector(\".\" + element.className);\n                if (el) {\n                    prop[index] = el;\n                }\n                else {\n                    throw new Error(`Could not find element with className: ${element.className}`);\n                }\n            }\n            if (element.id) {\n                const el = document.getElementById(element.id);\n                if (el) {\n                    prop[index] = el;\n                }\n                else {\n                    throw new Error(`Could not find element with id: ${element.id}`);\n                }\n            }\n        }\n    });\n};\n//Throws error if value is null or undefined\nexport function assertDefined(value) {\n    if (value == null) {\n        throw new Error(`Error: value ${value} cannot be null/undefined`);\n    }\n}\n//Function that throws an error if coords are undefined or not typeof number\nexport function assertRequired(coords) {\n    //IF there is no props in the provided object\n    if (Object.keys(coords).length <= 0)\n        throw new Error(`Error: no coords exist on this object`);\n    //IF the provided value of said object is not type of a number\n    Object.entries(coords).forEach(([k, v]) => {\n        if (typeof v !== \"number\")\n            throw new Error(`Error type ${k}:${v} must be of type number`);\n    });\n}\n//Function for incrementing and decrementing\nexport function incOrDec(index, action, steps) {\n    if (action === \"increment\") {\n        return (index += steps);\n    }\n    else {\n        return (index -= steps);\n    }\n}\n//Function for creating an html element\nexport const createPersonalElement = (type, parent, styles) => {\n    const element = document.createElement(type);\n    if (styles) {\n        Object.keys(styles).forEach((k) => {\n            Reflect.set(element.style, k, styles[k]);\n        });\n    }\n    parent.appendChild(element);\n    return element;\n};\n//# sourceMappingURL=common.js.map","import { OptionElement } from \"../types/elements\";\n//Removes nullish values from provided object\nexport const excludeNullishProps = <T extends object>(obj: T) => {\n  return Object.fromEntries(\n    Object.entries(obj).filter(([, v]) => typeof v !== \"undefined\" && v !== null)\n  ) as Valuble<T>;\n};\n\n//Assigns element passed to options to correct property\nexport const assignCorrectly = <T extends object, U extends OptionElement>(\n  element: U,\n  prop: T\n) => {\n  Object.keys(prop).map((key) => {\n    if (element.type === key) {\n      const index = key as keyof T;\n      if (!element.className && !element.id)\n        throw new Error(`Please provide a class or id for element: ${element.type}`);\n\n      if (element.className) {\n        const el = document.querySelector(\".\" + element.className) as T[keyof T];\n        if (el) {\n          prop[index] = el;\n        } else {\n          throw new Error(`Could not find element with className: ${element.className}`);\n        }\n      }\n\n      if (element.id) {\n        const el = document.getElementById(element.id) as T[keyof T];\n\n        if (el) {\n          prop[index] = el;\n        } else {\n          throw new Error(`Could not find element with id: ${element.id}`);\n        }\n      }\n    }\n  });\n};\n\n//Throws error if value is null or undefined\nexport function assertDefined<T>(value: T | null | undefined): asserts value is T {\n  if (value == null) {\n    throw new Error(`Error: value ${value} cannot be null/undefined`);\n  }\n}\n\n//Function that throws an error if coords are undefined or not typeof number\nexport function assertRequired<T extends object>(coords: T): asserts coords is Required<T> {\n  //IF there is no props in the provided object\n  if (Object.keys(coords).length <= 0) throw new Error(`Error: no coords exist on this object`);\n  //IF the provided value of said object is not type of a number\n  Object.entries(coords).forEach(([k, v]) => {\n    if (typeof v !== \"number\") throw new Error(`Error type ${k}:${v} must be of type number`);\n  });\n}\n\n//Function for incrementing and decrementing\nexport function incOrDec(index: number, action: \"increment\" | \"decrement\", steps: number) {\n  if (action === \"increment\") {\n    return (index += steps);\n  } else {\n    return (index -= steps);\n  }\n}\n\n//Function for creating an html element\nexport const createPersonalElement = <T extends keyof HTMLElementTagNameMap>(\n  type: T,\n  parent: HTMLElement,\n  styles?: Record<string, string | number>\n): HTMLElementTagNameMap[T] => {\n  const element = document.createElement(type);\n  if (styles) {\n    Object.keys(styles).forEach((k) => {\n      Reflect.set(element.style, k, styles[k]);\n    });\n  }\n  parent.appendChild(element);\n\n  return element;\n};\n","import { assertRequired } from \"./common.js\";\n//Returns coordinates based on if we are resizing or not\nexport function getCorrectCoords(drawing, resizing) {\n    let coords;\n    //Make sure that coords are not undefined\n    resizing ? assertRequired(drawing.resizedCoords) : assertRequired(drawing.coords);\n    if (drawing.type === \"line\") {\n        coords = {\n            startX: resizing ? drawing.resizedCoords.resizedStartX : drawing.coords.startX,\n            startY: resizing ? drawing.resizedCoords.resizedStartY : drawing.coords.startY,\n            endX: resizing ? drawing.resizedCoords.resizedEndX : drawing.coords.endX,\n            endY: resizing ? drawing.resizedCoords.resizedEndY : drawing.coords.endY,\n        };\n    }\n    else {\n        coords = {\n            x1: resizing ? drawing.resizedCoords.resizedX1 : drawing.coords.x1,\n            y1: resizing ? drawing.resizedCoords.resizedY1 : drawing.coords.y1,\n            x2: resizing ? drawing.resizedCoords.resizedX2 : drawing.coords.x2,\n            y2: resizing ? drawing.resizedCoords.resizedY2 : drawing.coords.y2,\n        };\n    }\n    return coords;\n}\n//# sourceMappingURL=overloads.js.map","import { DrawingElements, LineElement } from \"../types/elements\";\nimport { assertRequired } from \"./common.js\";\n\n//Return coords based on drawing type\nexport function getCorrectCoords<T extends DrawingElements>(\n  drawing: T,\n  resizing: Actions[\"resizing\"]\n): T extends LineElement ? Required<LineSelectionCoords> : Required<SelectionCoords>;\n\n//Returns coordinates based on if we are resizing or not\nexport function getCorrectCoords(drawing: DrawingElements, resizing: Actions[\"resizing\"]) {\n  let coords: Required<LineSelectionCoords> | Required<SelectionCoords>;\n\n  //Make sure that coords are not undefined\n  resizing ? assertRequired(drawing.resizedCoords) : assertRequired(drawing.coords);\n\n  if (drawing.type === \"line\") {\n    coords = {\n      startX: resizing ? drawing.resizedCoords.resizedStartX : drawing.coords.startX,\n      startY: resizing ? drawing.resizedCoords.resizedStartY : drawing.coords.startY,\n      endX: resizing ? drawing.resizedCoords.resizedEndX : drawing.coords.endX,\n      endY: resizing ? drawing.resizedCoords.resizedEndY : drawing.coords.endY,\n    } as Required<LineSelectionCoords>;\n  } else {\n    coords = {\n      x1: resizing ? drawing.resizedCoords.resizedX1 : drawing.coords.x1,\n      y1: resizing ? drawing.resizedCoords.resizedY1 : drawing.coords.y1,\n      x2: resizing ? drawing.resizedCoords.resizedX2 : drawing.coords.x2,\n      y2: resizing ? drawing.resizedCoords.resizedY2 : drawing.coords.y2,\n    } as Required<SelectionCoords>;\n  }\n\n  return coords;\n}\n"],"names":["$cca413c873b82bf5$export$e3c872aa2ab87149","obj","Object","fromEntries","entries","filter","v","$cca413c873b82bf5$export$6aa9081c568366ea","element","prop","keys","map","key","type","className","id","Error","el","document","querySelector","getElementById","$cca413c873b82bf5$export$953570f03e48e201","coords","length","forEach","k","$cca413c873b82bf5$export$c60994988c361040","index","action","steps","$cca413c873b82bf5$export$6d5a273f7a8fcfca","parent","styles","createElement","Reflect","set","style","appendChild","$9403128a2a74c1da$export$bf395ed26c12da18","drawing","resizing","resizedCoords","startX","resizedStartX","startY","resizedStartY","endX","resizedEndX","endY","resizedEndY","x1","resizedX1","y1","resizedY1","x2","resizedX2","y2","resizedY2","$44f51f21f2de7984$var$DrawingCanvas","canvas","context","controller","tools","pencil","eraser","moveAndResize","text","line","toolModifiers","color","width","canvasModifiers","clear","undo","actions","erasing","moving","writing","lining","shouldDraw","shouldErase","shouldMove","shouldResize","toggled","from","shouldLine","activeTools","mouseIsDown","isDragging","selectedDrawingIndex","pathObject","path","Path2D","resizedPath","lineWidth","strokeStyle","operation","xCords","yCords","resizedXCords","resizedYCords","textObject","font","resizedFont","baseline","lineObject","drawingData","mouseX","mouseY","selectedTool","constructor","elementId","options","getContext","elements","window","innerWidth","offsetLeft","height","innerHeight","offsetTop","cursor","name","classList","add","listen","addEventListener","pressDownHandler","mouseUpHandler","mouseMoveHandler","changeHandler","toolSelectHandler","e","target","colorPicker","lineWidthPicker","targetIs","value","Number","definedTools","definedCanvasModifiers","remove","clearRect","pop","redraw","evtType","touches","clientY","clientX","addCoords","selected","selectionPosition","mouseWithinSelection","i","isPointInStroke","canvasContainer","textInput","position","top","left","outline","background","border","setTimeout","focus","setCtxStyles","textWidth","measureText","textHeight","parseInt","Math","round","fillText","push","removeChild","blur","moveTo","String","min","max","selectedDrawing","updateToResized","lineTo","dx","dy","newPath","m","DOMMatrix","translate","addPath","scaleOriginXPos","scaleOriginYPos","scale","getScaleInfo","originalDistanceX","originalDistanceY","scaleOriginX","scaleOriginY","newDistanceX","newDistanceY","startCornerXPos","startCornerYPos","fontStringCopy","slice","fontSize","parseFloat","newFont","replace","toString","resizedFontSize","startCornerX","startCornerY","beginPath","stroke","closePath","preventDefault","x","y","dragging","currentMouseX","currentMouseY","includes","originalDistance","currentDistance","mouseIsIn","mouseWithin","topLeftX1","topLeftX2","topLeftY1","topLeftY2","topRightX1","topRightX2","topRightY1","topRightY2","bottomRightX1","bottomRightX2","bottomRightY1","bottomRightY2","bottomLeftX1","bottomLeftX2","bottomLeftY1","bottomLeftY2","createDrawingSelection","globalCompositeOperation","strokeRect","drawCornerPoints","arc","PI","lineCap","textBaseline"],"version":3,"file":"index.202fbc4e.js.map"}